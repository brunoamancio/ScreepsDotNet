# E4 ‚Äì Simulation Kernel (Room Processor)

**Status:** ‚ö†Ô∏è 85% Complete (3 passive systems missing)
**Last Updated:** January 21, 2026

---

## Overview

E4 completes the room simulation kernel by implementing the remaining passive systems that run every tick regardless of player intents. The RoomProcessor orchestration and most game mechanics are already in place from E2/E3.

**Completed:**
- ‚úÖ RoomProcessor orchestration (`RoomProcessor.cs`)
- ‚úÖ Intent validation pipeline (E3 - `IntentValidationStep`)
- ‚úÖ 11/11 intent handler families (E2 - 240/240 tests)
- ‚úÖ Passive systems: structure decay, controller downgrade, power effect decay, creep aging
- ‚úÖ Global systems: inter-room transfers, power creeps, market
- ‚úÖ Stats/telemetry infrastructure

**Missing (This Milestone):**
- ‚ùå Source energy regeneration
- ‚ùå Mineral regeneration with density changes
- ‚ùå Construction site decay

**Deferred to E5:**
- NPC spawning (invaders, source keepers) - requires global coordination

---

## Dependencies

**Upstream:**
- ‚úÖ E2 (Data & Storage Model) - 95% complete, handlers in place
- ‚úÖ E3 (Intent Validation) - 100% complete, integrated into RoomProcessor

**Blocked By:** None

**Blocks:**
- E5 (Global Systems) - builds on complete room processor
- E6 (Engine Loop Orchestration) - needs stable simulation kernel
- E7 (Parity Validation) - compares room diffs against Node.js

---

## Implementation Plan

### E4.1: Source Regeneration ‚ö†Ô∏è

**Status:** Not Started
**Effort:** 2-3 hours
**Tests:** 15 tests

**Deliverables:**
- `SourceRegenerationStep.cs` - Passive source energy regeneration
- `SourceRegenerationStepTests.cs` - 15 tests covering all scenarios

**Logic (from Node.js `sources/tick.js`):**

1. **Basic Regeneration:**
   - If `energy < energyCapacity` and `nextRegenerationTime` is null:
     - Set `nextRegenerationTime = gameTime + ENERGY_REGEN_TIME` (300 ticks)
   - If `gameTime >= nextRegenerationTime - 1`:
     - Reset `nextRegenerationTime = null`
     - Set `energy = energyCapacity`

2. **PWR_DISRUPT_SOURCE Effect:**
   - If source has PWR_DISRUPT_SOURCE effect active:
     - Increment `nextRegenerationTime` by 1 each tick (delays regeneration)

3. **PWR_REGEN_SOURCE Effect:**
   - If source has PWR_REGEN_SOURCE effect active:
     - Every `period` ticks (from POWER_INFO):
       - Add `effect[level - 1]` energy (up to `energyCapacity`)

4. **Capacity Adjustment:**
   - If room has controller with owner/reservation:
     - Set `energyCapacity = SOURCE_ENERGY_CAPACITY` (3000)
   - Else if room has no controller (keeper room):
     - Set `energyCapacity = SOURCE_ENERGY_KEEPER_CAPACITY` (4000)
   - Else (neutral room):
     - Set `energyCapacity = SOURCE_ENERGY_NEUTRAL_CAPACITY` (1500)
   - Clamp `energy` to new capacity if reduced

**Test Coverage (15 tests):**
1. ‚úÖ Source with full energy does nothing
2. ‚úÖ Source with depleted energy sets nextRegenerationTime
3. ‚úÖ Source regenerates when gameTime >= nextRegenerationTime - 1
4. ‚úÖ Source regeneration clears nextRegenerationTime
5. ‚úÖ PWR_DISRUPT_SOURCE delays regeneration by 1 tick each tick
6. ‚úÖ PWR_REGEN_SOURCE adds energy every period ticks
7. ‚úÖ PWR_REGEN_SOURCE respects energyCapacity
8. ‚úÖ Owned room sets capacity to 3000
9. ‚úÖ Reserved room sets capacity to 3000
10. ‚úÖ Neutral room sets capacity to 1500
11. ‚úÖ Keeper room sets capacity to 4000
12. ‚úÖ Capacity reduction clamps energy
13. ‚úÖ Multiple effects (DISRUPT + REGEN) work together
14. ‚úÖ Regeneration at exact boundary (gameTime == nextRegenerationTime - 1)
15. ‚úÖ Partial energy does not trigger regen until time reached

**Constants Used:**
- `ENERGY_REGEN_TIME` = 300
- `SOURCE_ENERGY_CAPACITY` = 3000
- `SOURCE_ENERGY_NEUTRAL_CAPACITY` = 1500
- `SOURCE_ENERGY_KEEPER_CAPACITY` = 4000
- `PWR_REGEN_SOURCE` power info (period, effect by level)

---

### E4.2: Mineral Regeneration ‚ö†Ô∏è

**Status:** Not Started
**Effort:** 2-3 hours
**Tests:** 12 tests

**Deliverables:**
- `MineralRegenerationStep.cs` - Passive mineral regeneration with density changes
- `MineralRegenerationStepTests.cs` - 12 tests covering all scenarios

**Logic (from Node.js `minerals/tick.js`):**

1. **Basic Regeneration:**
   - If `mineralAmount == 0` and `nextRegenerationTime` is null:
     - Set `nextRegenerationTime = gameTime + MINERAL_REGEN_TIME` (50000 ticks)
   - If `gameTime >= nextRegenerationTime - 1`:
     - Reset `nextRegenerationTime = null`
     - Set `mineralAmount = MINERAL_DENSITY[density]`
     - **Density Change Logic:**
       - If `density == DENSITY_LOW` or `density == DENSITY_ULTRA`:
         - Always change density
       - Else:
         - Change density with probability `MINERAL_DENSITY_CHANGE` (0.05 = 5%)
       - New density selected from `MINERAL_DENSITY_PROBABILITY` distribution
       - Repeat selection until new density != old density

2. **PWR_REGEN_MINERAL Effect:**
   - If mineral has PWR_REGEN_MINERAL effect active and `mineralAmount > 0`:
     - Every `period` ticks (from POWER_INFO):
       - Add `effect[level - 1]` minerals (no upper limit)

**Test Coverage (12 tests):**
1. ‚úÖ Mineral with amount > 0 does nothing
2. ‚úÖ Mineral with 0 amount sets nextRegenerationTime
3. ‚úÖ Mineral regenerates when gameTime >= nextRegenerationTime - 1
4. ‚úÖ Mineral regeneration clears nextRegenerationTime
5. ‚úÖ Density LOW always changes on regen
6. ‚úÖ Density ULTRA always changes on regen
7. ‚úÖ Density MODERATE/HIGH changes 5% of the time (statistical test)
8. ‚úÖ Density change never picks same density
9. ‚úÖ Regenerated amount matches MINERAL_DENSITY[density]
10. ‚úÖ PWR_REGEN_MINERAL adds minerals every period ticks
11. ‚úÖ PWR_REGEN_MINERAL only works if mineralAmount > 0
12. ‚úÖ PWR_REGEN_MINERAL has no upper limit

**Constants Used:**
- `MINERAL_REGEN_TIME` = 50000
- `MINERAL_DENSITY` = { [DENSITY_LOW]: 15000, [DENSITY_MODERATE]: 35000, [DENSITY_HIGH]: 70000, [DENSITY_ULTRA]: 100000 }
- `MINERAL_DENSITY_CHANGE` = 0.05
- `MINERAL_DENSITY_PROBABILITY` = { [1]: 0.1, [2]: 0.5, [3]: 0.9, [4]: 1.0 }
- `PWR_REGEN_MINERAL` power info (period, effect by level)

---

### E4.3: Construction Site Decay ‚ö†Ô∏è

**Status:** Not Started
**Effort:** 1 hour
**Tests:** 5 tests

**Deliverables:**
- `ConstructionSiteDecayStep.cs` - Sites age and decay
- `ConstructionSiteDecayStepTests.cs` - 5 tests

**Logic (from Node.js engine):**
- Construction sites have a timer (typically 50000 ticks)
- Each tick without progress, timer decrements
- When timer reaches 0, site is removed
- (Exact constants TBD - check Node.js `constructionSites/tick.js`)

**Test Coverage (5 tests):**
1. ‚úÖ Construction site decrements timer each tick
2. ‚úÖ Site with timer = 0 is removed
3. ‚úÖ Site worked on (progress increased) does not decay
4. ‚úÖ Multiple sites decay independently
5. ‚úÖ Site removal clears from room objects

**Constants Used:**
- `CONSTRUCTION_DECAY_TIME` (TBD - check Node.js)

---

### E4.4: Step Registration & Ordering ‚ö†Ô∏è

**Status:** Partially Complete
**Effort:** 1 hour

**Current Order (18 steps):**
```csharp
// 1. Intent validation (E3)
services.AddSingleton<IRoomProcessorStep, IntentValidationStep>();

// 2. Lifecycle (deaths, TTL, fatigue)
services.AddSingleton<IRoomProcessorStep, CreepLifecycleStep>();

// 3. Movement
services.AddSingleton<IRoomProcessorStep, MovementIntentStep>();

// 4. Spawn operations
services.AddSingleton<IRoomProcessorStep, SpawnIntentStep>();
services.AddSingleton<IRoomProcessorStep, SpawnSpawningStep>();

// 5. Tower actions
services.AddSingleton<IRoomProcessorStep, TowerIntentStep>();

// 6. Creep actions
services.AddSingleton<IRoomProcessorStep, CreepBuildRepairStep>();
services.AddSingleton<IRoomProcessorStep, HarvestIntentStep>();

// 7. Resource I/O
services.AddSingleton<IRoomProcessorStep, ResourceTransferIntentStep>();

// 8. Structure processing
services.AddSingleton<IRoomProcessorStep, LabIntentStep>();
services.AddSingleton<IRoomProcessorStep, LinkIntentStep>();
services.AddSingleton<IRoomProcessorStep, PowerSpawnIntentStep>();
services.AddSingleton<IRoomProcessorStep, FactoryIntentStep>();

// 9. Combat
services.AddSingleton<IRoomProcessorStep, CombatResolutionStep>();

// 10. Passive systems
services.AddSingleton<IRoomProcessorStep, StructureDecayStep>();
services.AddSingleton<IRoomProcessorStep, ControllerDowngradeStep>();

// 11. Controller actions (after passive downgrade)
services.AddSingleton<IRoomProcessorStep, ControllerIntentStep>();

// 12. Power system
services.AddSingleton<IRoomProcessorStep, PowerEffectDecayStep>();
services.AddSingleton<IRoomProcessorStep, PowerAbilityStep>();
services.AddSingleton<IRoomProcessorStep, PowerAbilityCooldownStep>();

// 13. Event logging
services.AddSingleton<IRoomProcessorStep, RoomIntentEventLogStep>();
```

**New Steps to Add:**
```csharp
// After HarvestIntentStep, before ResourceTransferIntentStep:
services.AddSingleton<IRoomProcessorStep, SourceRegenerationStep>();
services.AddSingleton<IRoomProcessorStep, MineralRegenerationStep>();

// After CreepBuildRepairStep, before HarvestIntentStep:
services.AddSingleton<IRoomProcessorStep, ConstructionSiteDecayStep>();
```

**Rationale:**
- Sources/minerals regenerate AFTER harvest intents (harvest depletes, regen replenishes)
- Construction sites decay AFTER build intents (build adds progress, decay checks timer)

---

## Success Criteria

E4 is complete when:
1. ‚úÖ All 3 passive systems implemented (source regen, mineral regen, construction decay)
2. ‚úÖ 32+ new tests passing (15 + 12 + 5)
3. ‚úÖ All existing tests still pass (354 tests from E2/E3)
4. ‚úÖ Steps registered in DI in correct order
5. ‚úÖ Code reviewed and follows coding standards
6. üìã Performance acceptable (<10ms per room target - measure in E6)
7. üìã Parity with Node.js (deferred to E7)

---

## Exit Criteria

**Milestone Complete:** When all 3 passive systems are implemented and tested

**Blocked Work Unblocked:**
- E5 (Global Systems) can proceed - room processor is stable
- E6 (Orchestration) can integrate - simulation kernel is complete
- E7 (Parity Validation) can compare - all mechanics implemented

---

## Deferred Features

**NPC Spawning (Invaders, Source Keepers):**
- **Reason:** Requires global coordination (E5 - Global Systems)
- **Details:** NPC spawning depends on global timers, room status, player activity across shards
- **Impact:** Private servers can function without NPCs for local testing
- **Timeline:** E5 implementation

**Nuker Launch:**
- **Reason:** Likely an intent handler (E2 scope), not passive system
- **Details:** Check if nuke launching is already in E2 handlers
- **Timeline:** E2 completion or E5

**Power Bank Decay:**
- **Reason:** Keeper rooms (E5 global system)
- **Timeline:** E5 implementation

---

## Reference Documents

- **E2 Handler Tracking:** `e2.md` (intent handlers, 95% complete)
- **E3 Validation:** `e3.md` (intent validation pipeline, 100% complete)
- **E5 Global Systems:** `e5.md` (NPC spawning, global mutations)
- **Roadmap:** `roadmap.md` (E1-E8 milestones)
- **Node.js Engine Source:**
  - `ScreepsNodeJs/engine/src/processor/intents/sources/tick.js`
  - `ScreepsNodeJs/engine/src/processor/intents/minerals/tick.js`
  - `ScreepsNodeJs/engine/src/processor/intents/constructionSites/tick.js`

---

## Implementation Notes

**Current State Analysis:**
- RoomProcessor orchestration is mature and stable
- 18 processor steps registered (E2 + E3 work)
- Mutation writers, stats sinks, memory persistence all working
- Integration with Driver layer complete
- **Only missing:** 3 passive regeneration/decay systems

**Why E4 Was Marked "Not Started":**
- Roadmap created before E2/E3 implementation
- E2/E3 work incrementally built the room processor infrastructure
- E4 was originally scoped as "build entire simulation kernel"
- Reality: E4 is now "complete the remaining passive systems"

**Estimated Completion Time:**
- SourceRegenerationStep: 2-3 hours
- MineralRegenerationStep: 2-3 hours
- ConstructionSiteDecayStep: 1 hour
- Testing & integration: 1 hour
- **Total:** 6-8 hours to complete E4

---

**Last Updated:** January 21, 2026 (Plan created)
**Status:** ‚ö†Ô∏è 85% Complete - 3 passive systems remaining (source/mineral regen, construction decay)
