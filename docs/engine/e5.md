# E5 – Global Systems

**Status:** Not Started (Placeholder for E2.3 cross-references)

This document tracks the E5 "Global Systems" work, which includes global mutations (user GCL, credits, resources), power effect tracking, market operations, NPC spawns, and shard messaging.

---

## Purpose

E5 implements global state mutations that affect users, shards, and cross-room systems. This is distinct from E2.3's room-level intent handlers.

**Key differences from E2.3:**
- **E2.3:** Room-level mutations (objects, room info, action logs)
- **E5:** Global-level mutations (user stats, global resources, cross-room effects)

---

## Blocked E2.3 Features

The following E2.3 features are **blocked** by E5 implementation and should be implemented **after** E5 global mutation infrastructure is in place:

### 1. User GCL Updates (Controller Intents)
**Blocking E2.3 Feature:** `ControllerIntentStep.ProcessUpgrade()` GCL accumulation
**E2 Reference:** `docs/engine/e2.md` → "Controller Intents (Deferred - PARITY-BLOCKING)"
**Parity Status:** ✅ **PARITY-CRITICAL** (required for E7 validation)

**What's blocked:**
- Node.js calls `bulkUsers.inc(target.user, 'gcl', boostedEffect)` on **EVERY** upgrade
- Both boosted AND non-boosted GCL gains are blocked
- Affects controller progress → user GCL progression

**What's needed from E5:**
1. Implement `IGlobalMutationWriter` interface with `IncrementUserGcl(userId, amount)` method
2. Add global mutation batching infrastructure (similar to room-level `IRoomMutationWriter`)
3. Wire global mutations into processor context
4. Flush global mutations to user documents at end of tick

**Implementation effort after E5:** 1-2 hours (just call `context.GlobalMutationWriter.IncrementUserGcl()`)

---

### 2. Boost Effects (GCL Component)
**Blocking E2.3 Feature:** `ControllerIntentStep.ProcessUpgrade()` boosted GCL gains
**E2 Reference:** `docs/engine/e2.md` → "Controller Intents (Deferred - PARITY-BLOCKING)"
**Parity Status:** ⚠️ **PARTIALLY COMPLETE** (controller progress done, GCL blocked)

**What's blocked:**
- Boost multipliers (GH: 1.5x, GH2O: 1.8x, XGH2O: 2.0x) apply to controller progress ✅ **COMPLETE**
- Boost multipliers apply to GCL gains ❌ **BLOCKED** (same issue as #1)

**What's needed from E5:**
- Same infrastructure as #1 (IGlobalMutationWriter)

**Implementation effort after E5:** Included in #1 (same code path)

---

### 3. PWR_OPERATE_LAB Power Effect
~~**UNBLOCKED** - Completed in E2.3 (January 21, 2026)~~
**Status:** ✅ **COMPLETE** - Power effect infrastructure implemented in E2.3
**E2 Reference:** `docs/engine/e2.md` → "Lab Reactions & Boosts"

**What was completed:**
- ✅ Power effect tracking system (`PowerEffectDecayStep`, `PowerAbilityStep`)
- ✅ Effect consumption in `LabIntentStep.ProcessRunReaction()`
- ✅ Reaction amount boost: 5 + effect bonus (levels 1-5: 7/9/11/13/15)
- ✅ 3 tests added (effect levels 1/3/5)

**Lesson learned:** Power effects are **room-local** (no global state), so they belonged in E2.3, not E5.

---

### 4. PWR_OPERATE_POWER Power Effect
~~**UNBLOCKED** - Completed in E2.3 (January 21, 2026)~~
**Status:** ✅ **COMPLETE** - Power effect infrastructure implemented in E2.3
**E2 Reference:** `docs/engine/e2.md` → "Structure Energy Routing"

**What was completed:**
- ✅ Effect consumption in `PowerSpawnIntentStep.ProcessPowerSpawn()`
- ✅ Processing amount boost: 1 + effect bonus (levels 1-5: 2/3/4/5/6)
- ✅ 3 tests added (effect levels 1/3/5)
- ✅ PowerInfo Effect array added: [1, 2, 3, 4, 5]

---

### 5. PWR_OPERATE_FACTORY Power Effect
~~**UNBLOCKED** - Completed in E2.3 (January 21, 2026)~~
**Status:** ✅ **COMPLETE** - Power effect infrastructure implemented in E2.3
**E2 Reference:** `docs/engine/e2.md` → "Structure Energy Routing"

**What was completed:**
- ✅ Effect consumption in `FactoryIntentStep.ProcessProduce()`
- ✅ Factory level boost for recipe gating: level + effect bonus (levels 1-5: +1/+2/+3/+4/+5)
- ✅ 3 tests added (effect levels 1/3/5 allowing level-gated commodities)
- ✅ PowerInfo Effect array added: [1, 2, 3, 4, 5]

---

### 6. PWR_GENERATE_OPS Power Ability
**Blocking E2.3 Feature:** `PowerAbilityStep` PWR_GENERATE_OPS ability
**E2 Reference:** `docs/engine/e2.md` → "Power Creep Abilities (Deferred)"
**Parity Status:** ✅ **PARITY-CRITICAL** (required for E7 validation)

**What's blocked:**
- Power creeps can use `PWR_GENERATE_OPS` to generate ops from user's global power balance
- Node.js behavior (usePower.js lines 57-69): Adds ops to power creep store, drops overflow if exceeds capacity
- Requires tracking user's global power balance (incremented by power spawns, decremented by generateOps)

**What's needed from E5:**
1. Implement `IGlobalMutationWriter.IncrementUserPower(userId, amount)` method
2. Implement `IGlobalMutationWriter.DecrementUserPower(userId, amount)` method
3. Add user power balance field to global user mutations

**Implementation effort after E5:** 1-2 hours
- Add generateOps case to `PowerAbilityStep.ProcessUsePower` switch
- Calculate ops amount: `powerInfo.Effect[level - 1]` (levels 1-5: 1/2/4/6/8 ops)
- Deduct from user power balance: `context.GlobalMutationWriter.DecrementUserPower(creep.UserId, opsCost)`
- Add ops to power creep store, drop overflow if exceeds capacity
- 2 tests: valid use (ops added), overflow (drops created)

---

### 7. User Power Balance Updates (Power Spawn)
**Blocking E2.3 Feature:** `PowerSpawnIntentStep.ProcessPowerSpawn()` power balance tracking
**E2 Reference:** `docs/engine/e2.md` → "Structure Energy Routing (Deferred Features)"
**Parity Status:** ✅ **PARITY-CRITICAL** (required for E7 validation)

**What's blocked:**
- Power spawns should increment user's global power balance when processing power
- Node.js behavior: Calls `bulkUsers.inc(powerSpawn.user, 'power', amount)` on every power processing
- Currently power is consumed but user balance is not tracked

**What's needed from E5:**
- Same infrastructure as #6 (`IGlobalMutationWriter.IncrementUserPower`)

**Implementation effort after E5:** 30 minutes
- In `ProcessPowerSpawn`, call `context.GlobalMutationWriter.IncrementUserPower(powerSpawn.UserId, amount)`
- No new tests needed (existing tests cover power spawn processing)

---

## E5 Deliverables (When Implemented)

### 1. Global Mutation Infrastructure
**Analogous to:** `IRoomMutationWriter` (room-level mutations)

**Interface:**
```csharp
public interface IGlobalMutationWriter
{
    // User stats
    void IncrementUserGcl(string userId, int amount);
    void IncrementUserPower(string userId, int amount);  // For power spawns
    void DecrementUserPower(string userId, int amount);  // For generateOps
    void IncrementUserCredits(string userId, int amount);
    void DecrementUserCredits(string userId, int amount);

    // User resources (for intershard operations)
    void IncrementUserResource(string userId, string resourceType, int amount);
    void DecrementUserResource(string userId, string resourceType, int amount);

    // Flush mutations to storage
    Task FlushAsync(CancellationToken token = default);
}
```

**Wiring:**
- Add `IGlobalMutationWriter` to `RoomProcessorContext` constructor
- Inject into `EngineHost` / `MainLoopGlobalProcessor`
- Flush after all room processors complete

---

### 2. Power Effect Tracking
~~**COMPLETED IN E2.3** (January 21, 2026)~~
**Status:** ✅ **NO LONGER NEEDED** - Implemented in E2.3 as part of Power Abilities work

**What was implemented:**
1. ✅ `PowerEffectDecayStep` - Removes expired effects each tick
2. ✅ `PowerAbilityStep` - Applies power effects to structures
3. ✅ Effect consumption in Lab/PowerSpawn/Factory handlers
4. ✅ 67 tests covering power effect lifecycle

**Lesson learned:** Power effects are room-local state, not global state. They didn't require E5 infrastructure.

---

### 3. Market Operations (Lower Priority)
**Note:** Market infrastructure already exists (`MarketIntentStep`), but global market order matching and NPC order generation are deferred.

---

### 4. NPC Spawns (Lower Priority)
**Note:** NPC spawn logic (invaders, source keepers) is room-level but uses global timers.

---

## Implementation Priority (When Starting E5)

### Phase 1: Global Mutations (Unblocks E2.3)
**Effort:** 2-3 days
**Unblocks:** User GCL updates, boost effects (GCL component)

1. Implement `IGlobalMutationWriter` interface
2. Add global mutation batching (similar to `BulkRoomMutationWriter`)
3. Wire into `RoomProcessorContext`
4. Add tests for GCL accumulation
5. **Go back to E2.3:** Implement controller GCL updates

---

### Phase 2: Power Effect Tracking (Unblocks E2.3 Lab Effects)
**Effort:** 1-2 days
**Unblocks:** PWR_OPERATE_LAB (lab reaction boosts)

1. Implement power effect decay processor
2. Add effect lookup helpers
3. Document power effect lifecycle
4. **Go back to E2.3:** Implement PWR_OPERATE_LAB in lab reactions

---

### Phase 3: Market & NPC (Post-E2.3)
**Effort:** 3-5 days
**Unblocks:** Nothing in E2.3 (market/NPC are independent features)

---

## Cross-References

**Master Roadmap:** `src/ScreepsDotNet.Engine/CLAUDE.md` → "Roadmap (E1-E8)"
- E5 roadmap entry with status, exit criteria, dependencies

**E2 Plan:** `docs/engine/e2.md`
- See "Controller Intents (Deferred - PARITY-BLOCKING)" for GCL details
- See "Lab Reactions & Boosts (Deferred)" for power effect details
- See "Deferred Features - Complexity Ranking" for effort estimates

**Driver CLAUDE.md:** `src/ScreepsDotNet.Driver/CLAUDE.md`
- Global mutations may require driver-level bulk writers (similar to D5)

---

## Success Criteria (When E5 is Complete)

1. ✅ `IGlobalMutationWriter` implemented and wired into processor context
2. ✅ User GCL updates work (controller upgrades accumulate GCL)
3. ✅ Boost effects apply to GCL gains (boosted upgrades give more GCL)
4. ✅ Power effect decay logic implemented
5. ✅ PWR_OPERATE_LAB boosts lab reaction amounts
6. ✅ All E2.3 blocked features unblocked and implemented
7. ✅ Tests pass for global mutations and power effects

---

**Last Updated:** January 20, 2026 (Created as placeholder for E2.3 cross-references)
