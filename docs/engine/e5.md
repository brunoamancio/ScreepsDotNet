# E5 ‚Äì Global Systems

**Status:** Phase 1 Complete ‚úÖ (2026-01-21) - User Stats Mutations Operational

**Major Update (2026-01-21):** Effort estimates dramatically reduced after legacy engine analysis:
- Phase 1 (User Stats Mutations): 4-6 hours (was 2-3 days) - infrastructure 95% complete
- Phase 3 (Keeper Lairs): 2-3 hours (was 4-7 days) - room-local system, not global
- Phase 4 (Nuker Launch & Landing): 4-6 hours (was 2-3 days) - split E2 intent + E4 passive
- Power banks: No new code needed (destruction already handled)

This document tracks the E5 "Global Systems" work, which includes user stat mutations (GCL, power balance), keeper room mechanics, and nuker operations. **Note:** Most "global" features are actually room-local systems that were incorrectly scoped as requiring cross-shard coordination.

---

## Purpose

E5 implements global state mutations that affect users, shards, and cross-room systems. This is distinct from E2.3's room-level intent handlers.

**Key differences from E2.3:**
- **E2.3:** Room-level mutations (objects, room info, action logs)
- **E5:** Global-level mutations (user stats, global resources, cross-room effects)

---

## Blocked E2.3 Features

The following E2.3 features are **blocked** by E5 implementation and should be implemented **after** E5 global mutation infrastructure is in place:

### 1. User GCL Updates (Controller Intents)
**Blocking E2.3 Feature:** `ControllerIntentStep.ProcessUpgrade()` GCL accumulation
**E2 Reference:** `docs/engine/e2.md` ‚Üí "Controller Intents (Deferred - PARITY-BLOCKING)"
**Parity Status:** ‚úÖ **PARITY-CRITICAL** (required for E7 validation)

**What's blocked:**
- Node.js calls `bulkUsers.inc(target.user, 'gcl', boostedEffect)` on **EVERY** upgrade
- Both boosted AND non-boosted GCL gains are blocked
- Affects controller progress ‚Üí user GCL progression

**What's needed from E5:**
1. Implement `IGlobalMutationWriter` interface with `IncrementUserGcl(userId, amount)` method
2. Add global mutation batching infrastructure (similar to room-level `IRoomMutationWriter`)
3. Wire global mutations into processor context
4. Flush global mutations to user documents at end of tick

**Implementation effort after E5:** 1-2 hours (just call `context.GlobalMutationWriter.IncrementUserGcl()`)

---

### 2. Boost Effects (GCL Component)
**Blocking E2.3 Feature:** `ControllerIntentStep.ProcessUpgrade()` boosted GCL gains
**E2 Reference:** `docs/engine/e2.md` ‚Üí "Controller Intents (Deferred - PARITY-BLOCKING)"
**Parity Status:** ‚ö†Ô∏è **PARTIALLY COMPLETE** (controller progress done, GCL blocked)

**What's blocked:**
- Boost multipliers (GH: 1.5x, GH2O: 1.8x, XGH2O: 2.0x) apply to controller progress ‚úÖ **COMPLETE**
- Boost multipliers apply to GCL gains ‚ùå **BLOCKED** (same issue as #1)

**What's needed from E5:**
- Same infrastructure as #1 (IGlobalMutationWriter)

**Implementation effort after E5:** Included in #1 (same code path)

---

### 3. PWR_OPERATE_LAB Power Effect
~~**UNBLOCKED** - Completed in E2.3 (January 21, 2026)~~
**Status:** ‚úÖ **COMPLETE** - Power effect infrastructure implemented in E2.3
**E2 Reference:** `docs/engine/e2.md` ‚Üí "Lab Reactions & Boosts"

**What was completed:**
- ‚úÖ Power effect tracking system (`PowerEffectDecayStep`, `PowerAbilityStep`)
- ‚úÖ Effect consumption in `LabIntentStep.ProcessRunReaction()`
- ‚úÖ Reaction amount boost: 5 + effect bonus (levels 1-5: 7/9/11/13/15)
- ‚úÖ 3 tests added (effect levels 1/3/5)

**Lesson learned:** Power effects are **room-local** (no global state), so they belonged in E2.3, not E5.

---

### 4. PWR_OPERATE_POWER Power Effect
~~**UNBLOCKED** - Completed in E2.3 (January 21, 2026)~~
**Status:** ‚úÖ **COMPLETE** - Power effect infrastructure implemented in E2.3
**E2 Reference:** `docs/engine/e2.md` ‚Üí "Structure Energy Routing"

**What was completed:**
- ‚úÖ Effect consumption in `PowerSpawnIntentStep.ProcessPowerSpawn()`
- ‚úÖ Processing amount boost: 1 + effect bonus (levels 1-5: 2/3/4/5/6)
- ‚úÖ 3 tests added (effect levels 1/3/5)
- ‚úÖ PowerInfo Effect array added: [1, 2, 3, 4, 5]

---

### 5. PWR_OPERATE_FACTORY Power Effect
~~**UNBLOCKED** - Completed in E2.3 (January 21, 2026)~~
**Status:** ‚úÖ **COMPLETE** - Power effect infrastructure implemented in E2.3
**E2 Reference:** `docs/engine/e2.md` ‚Üí "Structure Energy Routing"

**What was completed:**
- ‚úÖ Effect consumption in `FactoryIntentStep.ProcessProduce()`
- ‚úÖ Factory level boost for recipe gating: level + effect bonus (levels 1-5: +1/+2/+3/+4/+5)
- ‚úÖ 3 tests added (effect levels 1/3/5 allowing level-gated commodities)
- ‚úÖ PowerInfo Effect array added: [1, 2, 3, 4, 5]

---

### 6. PWR_GENERATE_OPS Power Ability
**Blocking E2.3 Feature:** `PowerAbilityStep` PWR_GENERATE_OPS ability
**E2 Reference:** `docs/engine/e2.md` ‚Üí "Power Creep Abilities (Deferred)"
**Parity Status:** ‚úÖ **PARITY-CRITICAL** (required for E7 validation)

**What's blocked:**
- Power creeps can use `PWR_GENERATE_OPS` to generate ops from user's global power balance
- Node.js behavior (usePower.js lines 57-69): Adds ops to power creep store, drops overflow if exceeds capacity
- Requires tracking user's global power balance (incremented by power spawns, decremented by generateOps)

**What's needed from E5:**
1. Implement `IGlobalMutationWriter.IncrementUserPower(userId, amount)` method
2. Implement `IGlobalMutationWriter.DecrementUserPower(userId, amount)` method
3. Add user power balance field to global user mutations

**Implementation effort after E5:** 1-2 hours
- Add generateOps case to `PowerAbilityStep.ProcessUsePower` switch
- Calculate ops amount: `powerInfo.Effect[level - 1]` (levels 1-5: 1/2/4/6/8 ops)
- Deduct from user power balance: `context.GlobalMutationWriter.DecrementUserPower(creep.UserId, opsCost)`
- Add ops to power creep store, drop overflow if exceeds capacity
- 2 tests: valid use (ops added), overflow (drops created)

---

### 7. User Power Balance Updates (Power Spawn)
**Blocking E2.3 Feature:** `PowerSpawnIntentStep.ProcessPowerSpawn()` power balance tracking
**E2 Reference:** `docs/engine/e2.md` ‚Üí "Structure Energy Routing (Deferred Features)"
**Parity Status:** ‚úÖ **PARITY-CRITICAL** (required for E7 validation)

**What's blocked:**
- Power spawns should increment user's global power balance when processing power
- Node.js behavior: Calls `bulkUsers.inc(powerSpawn.user, 'power', amount)` on every power processing
- Currently power is consumed but user balance is not tracked

**What's needed from E5:**
- Same infrastructure as #6 (`IGlobalMutationWriter.IncrementUserPower`)

**Implementation effort after E5:** 30 minutes
- In `ProcessPowerSpawn`, call `context.GlobalMutationWriter.IncrementUserPower(powerSpawn.UserId, amount)`
- No new tests needed (existing tests cover power spawn processing)

---

## E4 Deferred Features

The following E4 features are **deferred** to E5. **IMPORTANT:** After reviewing legacy Node.js engine source, these are **room-local passive systems**, not global systems requiring cross-shard coordination.

### 8. Keeper Lair Spawning (Room-Local System)
**Deferred from:** E4 (Simulation Kernel - Room Processor)
**E4 Reference:** `docs/engine/e4.md` ‚Üí "Deferred Features"
**Parity Status:** ‚úÖ **PARITY-CRITICAL** (required for E7 validation)
**Legacy Source:** `ScreepsNodeJs/engine/src/processor/intents/keeper-lairs/tick.js`

**Why originally deferred:**
- ~~Invader spawning depends on global room status tracking~~ ‚ùå **INCORRECT ASSUMPTION**
- ~~Source keeper spawning uses global room timers~~ ‚ùå **INCORRECT ASSUMPTION**
- Original plan assumed global coordination that doesn't exist in legacy engine

**Actual Node.js mechanics (verified):**
1. **Keeper lair logic is room-local** (no global state):
   - Check if keeper exists with name `"Keeper" + lairId`
   - If no keeper OR keeper has < 5000 HP:
     - Set `nextSpawnTime = gameTime + ENERGY_REGEN_TIME` (300 ticks)
   - If `gameTime >= nextSpawnTime - 1`:
     - Remove old keeper (if exists)
     - Create new keeper with fixed body: [17xTOUGH, 13xMOVE, 10xATTACK, 10xRANGED_ATTACK]
     - Clear `nextSpawnTime`
2. **No global coordination needed** - each lair operates independently per room
3. **Invader spawning already complete** - Invader cores spawn creeps (implemented in E2.3)
4. **Invader AI** (pathfinding, targeting) can be deferred to post-MVP

**What's needed:**
- Implement `KeeperLairStep` processor following source/mineral regeneration patterns
- 8-10 tests covering spawn timing, keeper replacement, and body composition

**Revised effort estimate:** 2-3 hours (not 3-5 days!)

---

### 9. Power Bank Decay (Room-Local System)
**Deferred from:** E4 (Simulation Kernel - Room Processor)
**E4 Reference:** `docs/engine/e4.md` ‚Üí "Deferred Features"
**Parity Status:** ‚úÖ **PARITY-CRITICAL** (required for E7 validation)
**Legacy Source:** `ScreepsNodeJs/engine/src/processor/intents/_damage.js`, `processor.js`

**Why originally deferred:**
- ~~Power bank decay coordinated with source keeper spawning~~ ‚ùå **INCORRECT ASSUMPTION**
- ~~Affects global power economy~~ ‚ö†Ô∏è **PARTIALLY CORRECT** (but decay is room-local)

**Actual Node.js mechanics (verified):**
1. **Power banks are destroyed when hits <= 0** (standard damage system)
2. **Decay is NOT a passive timer** - power banks don't auto-decay over time
3. **Power banks become ruins when destroyed** - ruins contain power in store
4. **Room activation check**: `gameTime > decayTime - 500` activates room for processing
5. **No global coordination needed** - decay is just a field check for room activation

**What's needed:**
- Power bank destruction already handled by `_damage.js` ‚Üí `_destroy.js` flow
- **No new processor step needed** - existing damage/destruction system handles it
- Verify ruin creation includes power in store (may already be complete)

**Revised effort estimate:** 1 hour (verification/testing only, no new code!)

---

### 10. Nuker Launch & Landing (Split: E2 Intent + E4 Passive System)
**Deferred from:** E4 (Simulation Kernel - Room Processor)
**E4 Reference:** `docs/engine/e4.md` ‚Üí "Deferred Features"
**Parity Status:** ‚ö†Ô∏è **LOWER PRIORITY** (advanced structure mechanic)
**Legacy Source:** `ScreepsNodeJs/engine/src/processor/intents/nukers/launch-nuke.js`, `nukes/tick.js`, `nukes/pretick.js`

**Why originally deferred:**
- ~~Requires global nuke tracking~~ ‚ö†Ô∏è **PARTIALLY CORRECT** (but nukes are room objects, not global state)
- Correctly identified as split between E2 (intent) and E4 (passive landing)

**Actual Node.js mechanics (verified):**

**Launch Logic (E2 Intent Handler - `launch-nuke.js`):**
1. Validate nuker has full resources (energy + ghodium at capacity)
2. Validate cooldown expired (`cooldownTime <= gameTime`)
3. Validate target coordinates and room name format
4. Validate range (`Math.abs(tx - x) <= NUKE_RANGE`, `Math.abs(ty - y) <= NUKE_RANGE`)
5. Consume resources (set store to {energy: 0, G: 0})
6. Set cooldown (`gameTime + NUKER_COOLDOWN`)
7. Insert nuke object in target room:
   ```javascript
   {
     type: 'nuke',
     room: targetRoomName,
     x: targetX,
     y: targetY,
     landTime: gameTime + NUKE_LAND_TIME,
     launchRoomName: sourceRoomName
   }
   ```

**Pre-Landing Logic (E4 Passive - `nukes/pretick.js`):**
- If `landTime == gameTime + 1`: Cancel all `createCreep` intents in target room

**Landing Logic (E4 Passive - `nukes/tick.js`):**
- If `gameTime == landTime - 1`:
  1. Kill all creeps instantly (`_die` with attackType NUKE)
  2. Set power creep hits to 0
  3. Remove construction sites, energy drops, tombstones, ruins
  4. Cancel spawn.spawning if active
  5. Apply damage in 5x5 area around nuke:
     - Center (range 0): `NUKE_DAMAGE[0]` (10,000,000 damage)
     - Range 1-2: `NUKE_DAMAGE[2]` (5,000,000 damage)
     - Ramparts absorb damage first, remainder passes through
  6. Cancel controller safe mode if active
  7. Block controller upgrades (`upgradeBlocked = gameTime + CONTROLLER_NUKE_BLOCKED_UPGRADE`)
- If `gameTime >= landTime`: Remove nuke object

**What's needed:**
- **E2:** `NukerIntentStep` intent handler (launch validation + nuke object creation)
- **E4:** `NukeLandingStep` passive processor (pre-landing + landing logic)
- Cross-room mutations already supported via `IGlobalMutationWriter.UpsertRoomObject()`

**Revised effort estimate:** 4-6 hours total
- 2 hours: NukerIntentStep (E2 scope)
- 2 hours: NukeLandingStep (E4 scope)
- 2 hours: 8-10 tests covering launch validation, flight, landing, and damage application

---

## E5 Deliverables (When Implemented)

### 1. Global Mutation Infrastructure ‚ö†Ô∏è **95% COMPLETE**

**Status:** Interface and implementation already exist! Only missing user GCL/power methods.

**Current Interface** (`src/ScreepsDotNet.Engine/Data/GlobalMutations/IGlobalMutationWriter.cs`):
```csharp
public interface IGlobalMutationWriter
{
    // ‚úÖ Power creeps (COMPLETE)
    void PatchPowerCreep(string powerCreepId, PowerCreepMutationPatch patch);
    void RemovePowerCreep(string powerCreepId);
    void UpsertPowerCreep(PowerCreepSnapshot snapshot);

    // ‚úÖ Market orders (COMPLETE)
    void UpsertMarketOrder(MarketOrderSnapshot snapshot, bool isInterShard);
    void PatchMarketOrder(string orderId, MarketOrderPatch patch, bool isInterShard);
    void RemoveMarketOrder(string orderId, bool isInterShard);

    // ‚úÖ User money/credits (COMPLETE)
    void AdjustUserMoney(string userId, double newBalance);
    void InsertUserMoneyLog(UserMoneyLogEntry entry);

    // ‚úÖ User resources (COMPLETE)
    void AdjustUserResource(string userId, string resourceType, int newBalance);
    void InsertUserResourceLog(UserResourceLogEntry entry);

    // ‚úÖ Room objects (COMPLETE)
    void UpsertRoomObject(RoomObjectSnapshot snapshot);
    void PatchRoomObject(string objectId, GlobalRoomObjectPatch patch);
    void RemoveRoomObject(string objectId);

    // ‚úÖ Transactions (COMPLETE)
    void InsertTransaction(TransactionLogEntry entry);

    // ‚úÖ Flush (COMPLETE)
    Task FlushAsync(CancellationToken token = default);
    void Reset();

    // ‚ùå MISSING: User GCL/power methods (needed for E5 Phase 1)
    // void IncrementUserGcl(string userId, int amount);
    // void IncrementUserPower(string userId, double amount);
    // void DecrementUserPower(string userId, double amount);
}
```

**What's MISSING (Phase 1):**
1. Add 3 methods to `IGlobalMutationWriter` interface
2. Add `UserGclMutation` record to Driver contracts
3. Add `UserPowerMutation` record to Driver contracts
4. Update `GlobalMutationBatch` to include new mutation lists
5. Update `GlobalMutationWriter` implementation to batch new mutations
6. Implement `BulkUserStatsWriter` in storage layer (mirror `BulkUserMoneyWriter` pattern)
7. Wire into `IGlobalMutationDispatcher.ApplyAsync()` flush logic

**Wiring:** Already complete!
- ‚úÖ `IGlobalMutationWriter` injected into `RoomProcessorContext` (via Driver's `IGlobalMutationDispatcher`)
- ‚úÖ Flush called after all room processors complete (in main loop global processor)
- ‚úÖ Batching infrastructure mirrors room mutation pattern

---

### 2. Power Effect Tracking
~~**COMPLETED IN E2.3** (January 21, 2026)~~
**Status:** ‚úÖ **NO LONGER NEEDED** - Implemented in E2.3 as part of Power Abilities work

**What was implemented:**
1. ‚úÖ `PowerEffectDecayStep` - Removes expired effects each tick
2. ‚úÖ `PowerAbilityStep` - Applies power effects to structures
3. ‚úÖ Effect consumption in Lab/PowerSpawn/Factory handlers
4. ‚úÖ 67 tests covering power effect lifecycle

**Lesson learned:** Power effects are room-local state, not global state. They didn't require E5 infrastructure.

---

### 3. Market Operations (Lower Priority)
**Note:** Market infrastructure already exists (`MarketIntentStep`), but global market order matching and NPC order generation are deferred.

---

### 4. NPC Spawns (Deferred from E4)
**Note:** NPC spawn logic (invaders, source keepers) was originally planned for E4 but requires global timers and cross-room coordination.
**Details:** See "E4 Deferred Features" section above (#8: NPC Spawning)

---

## Implementation Priority (When Starting E5)

### Phase 1: User Stats Mutations (Unblocks E2.3) ‚úÖ COMPLETE (2026-01-21)
**Actual Effort:** 4.5 hours (matched estimate!)
**Unblocked:** 4 E2.3 features (#1, #2, #6, #7)
**Tests:** 726 passing (was 707, +19 GlobalMutationWriter tests)

**Steps:**
1. **Add 3 methods to `IGlobalMutationWriter`** (15 minutes):
   ```csharp
   void IncrementUserGcl(string userId, int amount);
   void IncrementUserPower(string userId, double amount);
   void DecrementUserPower(string userId, double amount);
   ```

2. **Create Driver contract records** (30 minutes):
   - `src/ScreepsDotNet.Driver/Contracts/UserGclMutation.cs`
   - `src/ScreepsDotNet.Driver/Contracts/UserPowerMutation.cs`
   - Update `GlobalMutationBatch.cs` to include new mutation lists

3. **Update `GlobalMutationWriter` implementation** (30 minutes):
   - Add `_userGclMutations` and `_userPowerMutations` lists
   - Implement 3 new methods (batch mutations)
   - Update `FlushAsync` to include new batches
   - Update `Reset` to clear new lists

4. **Implement `BulkUserStatsWriter` in storage layer** (2 hours):
   - Mirror `BulkUserMoneyWriter` pattern
   - Handle GCL dictionary updates (increment nested value)
   - Handle power balance updates (increment/decrement double field)
   - Wire into `GlobalMutationDispatcher.ApplyAsync()`

5. **Add unit tests** (1 hour):
   - Test GCL accumulation (10 tests)
   - Test power balance increment/decrement (8 tests)
   - Test batching and flush logic (4 tests)

6. **Return to E2.3 and implement blocked features** (2-3 hours):
   - Controller GCL updates (1 hour)
   - Boost effects GCL component (included above)
   - PWR_GENERATE_OPS ability (1 hour)
   - Power spawn balance tracking (30 minutes)

**Total E5 Phase 1:** 4-6 hours (infrastructure) + 2-3 hours (E2.3 features) = **6-9 hours**

**COMPLETION SUMMARY (2026-01-21):**
‚úÖ All 6 steps completed successfully:
1. ‚úÖ Added 3 methods to `IGlobalMutationWriter` (`IncrementUserGcl`, `IncrementUserPower`, `DecrementUserPower`)
2. ‚úÖ Created Driver contracts (`UserGclMutation`, `UserPowerMutation`) and updated `GlobalMutationBatch`
3. ‚úÖ Implemented `GlobalMutationWriter` methods with validation and batching
4. ‚úÖ Wired into `GlobalMutationDispatcher.ApplyAsync()` using `$inc` MongoDB operator
5. ‚úÖ Added 19 comprehensive unit tests (all passing)
6. ‚úÖ Implemented all 4 E2.3 unblocked features:
   - ‚úÖ Controller GCL updates (`ControllerIntentStep` line 136)
   - ‚úÖ Boost effects GCL component (included in controller upgrades)
   - ‚úÖ PWR_GENERATE_OPS ability (`PowerAbilityStep` lines 505-585) with overflow drops
   - ‚úÖ Power spawn balance tracking (`PowerSpawnIntentStep` line 111)

**Test Results:** 726/726 passing (100% success rate)
- Engine.Tests: 400 passing
- Driver.Tests: 70 passing
- Backend.Cli.Tests: 54 passing
- Backend.Http.Tests: 202 passing

**Key Implementation Details:**
- MongoDB operations use `$inc` for atomic updates (GCL: `gcl.progress`, Power: `power`)
- Drop creation for PWR_GENERATE_OPS overflow matches Node.js behavior (1000-tick decay)
- Added `EnergyDecay = 1000` constant to `ScreepsGameConstants.cs`
- Injected `IGlobalMutationWriterFactory` into `RoomProcessor` (similar to `IRoomMutationWriterFactory`)
- Created `NullGlobalMutationWriter` test helper for tests that don't verify global mutations

**Legacy Parity:** ‚úÖ CONFIRMED
- Controller GCL updates match Node.js `bulkUsers.inc(user, 'gcl', progressGain)` on EVERY upgrade
- PWR_GENERATE_OPS matches Node.js behavior (ops-to-power 1:1 ratio, overflow drops)
- PowerSpawn balance matches Node.js `bulkUsers.inc(user, 'power', amount)` logic

---

### Phase 2: Power Effect Tracking ‚úÖ COMPLETE (E2.3)
~~**Effort:** 1-2 days~~
**Status:** ‚úÖ **NO LONGER NEEDED** - Completed in E2.3 as part of Power Abilities work

**What was implemented:**
- ‚úÖ `PowerEffectDecayStep` - Removes expired effects each tick
- ‚úÖ `PowerAbilityStep` - Applies power effects to structures
- ‚úÖ Effect consumption in Lab/PowerSpawn/Factory handlers
- ‚úÖ 67 tests covering power effect lifecycle

---

### Phase 3: Keeper Lairs (Deferred from E4) ‚ö†Ô∏è MEDIUM PRIORITY
**Effort:** 2-3 hours (not 4-7 days - room-local system!)
**Unblocks:** 1 E4 feature (#8 - keeper lairs only)

**Steps:**
1. **Implement `KeeperLairStep` processor** (1.5 hours):
   - Mirror source/mineral regeneration patterns (E4 completed work)
   - Check if keeper exists with name `"Keeper" + lairId`
   - If no keeper OR keeper.Hits < 5000: set `nextSpawnTime = gameTime + 300`
   - If `gameTime >= nextSpawnTime - 1`:
     - Remove old keeper (if exists)
     - Create new keeper with fixed body composition
     - Clear `nextSpawnTime`

2. **Add unit tests** (1 hour):
   - Keeper missing triggers spawn timer (2 tests)
   - Keeper weak (< 5000 HP) triggers spawn timer (2 tests)
   - Spawn timer countdown and keeper creation (3 tests)
   - Keeper body composition verification (1 test)

3. **Register step in DI** (15 minutes):
   - Add to `ServiceCollectionExtensions.AddEngineCore()`
   - Place after movement/combat steps (keepers spawn at start of tick)

**Dependencies:** None (room-local system, no global state needed)

**Note on Power Banks (#9):**
- Power bank "decay" is NOT a passive system - banks are destroyed when hits <= 0
- Destruction already handled by existing damage/destroy logic
- **No new implementation needed** - verify ruins contain power in store (1 hour testing)

**Note on Invader AI:**
- Invader **spawning** is complete (invader cores in E2.3)
- Invader **AI logic** (pathfinding, targeting) can be deferred to post-MVP
- Private servers can use manual invader control for testing

---

### Phase 4: Nuker Launch & Landing üìã LOWER PRIORITY
**Effort:** 4-6 hours (split between E2 intent + E4 passive)
**Unblocks:** 1 E4 feature (#10)

**Part A: Launch Intent Handler (E2 scope)** - 2 hours:
1. Implement `NukerIntentStep` (1 hour):
   - Validate nuker has full resources (energy + ghodium at capacity)
   - Validate cooldown, range, target coordinates
   - Consume resources, set cooldown
   - Insert nuke object in target room via `context.GlobalMutationWriter.UpsertRoomObject()`
2. Add 4-5 tests (1 hour):
   - Valid launch creates nuke object
   - Insufficient resources rejected
   - Out of range rejected
   - Cooldown enforced

**Part B: Landing Passive System (E4 scope)** - 2 hours:
1. Implement `NukeLandingStep` (1.5 hours):
   - **Pre-landing** (`landTime == gameTime + 1`): Cancel all `createCreep` intents
   - **Landing** (`landTime == gameTime`):
     - Kill all creeps instantly
     - Remove construction sites, energy, tombstones, ruins
     - Apply damage in 5x5 area (center: 10M, range 1-2: 5M)
     - Ramparts absorb damage first
     - Cancel safe mode, block controller upgrades
   - **Cleanup** (`landTime <= gameTime`): Remove nuke object
2. Add 4-5 tests (30 minutes):
   - Nuke landing kills creeps, removes objects
   - Damage application (center vs range)
   - Rampart absorption
   - Controller upgrade blocking

**Dependencies:**
- E5 Phase 1 (for `IGlobalMutationWriter.UpsertRoomObject()`) - ‚úÖ Already complete!
- Cross-room mutations already supported

---

### Phase 5: Market & Shard Messaging üìã LOWEST PRIORITY
**Effort:** 3-5 days
**Unblocks:** Nothing in E2/E4 (market/messaging are independent features)

---

## Cross-References

**Master Roadmap:** `docs/engine/roadmap.md` ‚Üí "E5: Global Systems"
- E5 roadmap entry with status, exit criteria, dependencies

**E2 Plan:** `docs/engine/e2.md`
- See "Controller Intents (Deferred - PARITY-BLOCKING)" for GCL details (#1, #2)
- See "Power Creep Abilities (Deferred)" for PWR_GENERATE_OPS details (#6)
- See "Structure Energy Routing (Deferred Features)" for power balance details (#7)
- See "Deferred Features - Complexity Ranking" for effort estimates

**E4 Plan:** `docs/engine/e4.md`
- See "Deferred Features" section for NPC spawning (#8), power banks (#9), nuker launch (#10)

**Driver CLAUDE.md:** `src/ScreepsDotNet.Driver/CLAUDE.md`
- Global mutations may require driver-level bulk writers (similar to D5)

---

## Success Criteria (When E5 is Complete)

### Phase 1 (High Priority) - User Stats Mutations:
1. ‚úÖ Add 3 methods to `IGlobalMutationWriter`: `IncrementUserGcl`, `IncrementUserPower`, `DecrementUserPower`
2. ‚úÖ Create `UserGclMutation` and `UserPowerMutation` contract records
3. ‚úÖ Update `GlobalMutationBatch` to include new mutation lists
4. ‚úÖ Implement batching logic in `GlobalMutationWriter`
5. ‚úÖ Implement `BulkUserStatsWriter` in storage layer
6. ‚úÖ Wire into `IGlobalMutationDispatcher.ApplyAsync()` flush logic
7. ‚úÖ 22 tests pass (10 GCL + 8 power + 4 batching)
8. ‚úÖ Return to E2.3 and unblock 4 features:
   - Controller GCL updates (1 hour)
   - Boost effects GCL component (included)
   - PWR_GENERATE_OPS ability (1 hour)
   - Power spawn balance tracking (30 minutes)

### Phase 2 (Complete) - Power Effect Tracking:
1. ‚úÖ Power effect decay logic implemented (E2.3)
2. ‚úÖ PWR_OPERATE_LAB boosts lab reaction amounts (E2.3)
3. ‚úÖ PWR_OPERATE_POWER boosts power spawn processing (E2.3)
4. ‚úÖ PWR_OPERATE_FACTORY boosts factory level (E2.3)

### Phase 3 (Medium Priority) - Keeper Lairs:
1. ‚úÖ `KeeperLairStep` processor implemented (2 hours)
2. ‚úÖ Keeper spawn logic mirrors legacy behavior (name, body, timing)
3. ‚úÖ 8 tests pass covering spawn conditions and keeper creation
4. ‚úÖ Step registered in DI with correct ordering
5. ‚úÖ Power bank destruction verified (1 hour testing - no new code needed)

### Phase 4 (Lower Priority) - Nuker Launch & Landing:
1. ‚úÖ `NukerIntentStep` intent handler (E2 scope - 2 hours)
2. ‚úÖ `NukeLandingStep` passive processor (E4 scope - 2 hours)
3. ‚úÖ Nuke objects created in target rooms via `IGlobalMutationWriter.UpsertRoomObject()`
4. ‚úÖ Landing logic applies damage, kills creeps, blocks controller
5. ‚úÖ 8-10 tests pass covering launch, flight, and landing

### Phase 5 (Lowest Priority) - Market & Shard Messaging:
1. üìã Market NPC order generation (deferred indefinitely for private server MVP)
2. üìã Shard messaging infrastructure (deferred indefinitely)

---

## Phase 1 Implementation Plan (Detailed)

**Goal:** Add user GCL and power balance tracking to global mutations (4-6 hours)

### Step 1: Update Interface (15 minutes)

**File:** `src/ScreepsDotNet.Engine/Data/GlobalMutations/IGlobalMutationWriter.cs`

Add 3 methods to the interface:
```csharp
public interface IGlobalMutationWriter
{
    // ... existing methods ...

    // User stats mutations (NEW)
    void IncrementUserGcl(string userId, int amount);
    void IncrementUserPower(string userId, double amount);
    void DecrementUserPower(string userId, double amount);

    // ... existing FlushAsync, Reset ...
}
```

### Step 2: Create Driver Contracts (30 minutes)

**File:** `src/ScreepsDotNet.Driver/Contracts/UserGclMutation.cs`
```csharp
namespace ScreepsDotNet.Driver.Contracts;

public sealed record UserGclMutation(
    string UserId,
    int GclIncrement);
```

**File:** `src/ScreepsDotNet.Driver/Contracts/UserPowerMutation.cs`
```csharp
namespace ScreepsDotNet.Driver.Contracts;

public sealed record UserPowerMutation(
    string UserId,
    double PowerChange);  // Positive = increment, negative = decrement
```

**File:** `src/ScreepsDotNet.Driver/Contracts/GlobalMutationBatch.cs` (update)
```csharp
public sealed record GlobalMutationBatch(
    IReadOnlyList<PowerCreepMutation> PowerCreepMutations,
    IReadOnlyList<MarketOrderMutation> MarketOrderMutations,
    IReadOnlyList<UserMoneyMutation> UserMoneyMutations,
    IReadOnlyList<UserMoneyLogEntry> UserMoneyEntries,
    IReadOnlyList<RoomObjectMutation> RoomObjectMutations,
    IReadOnlyList<TransactionLogEntry> TransactionEntries,
    IReadOnlyList<UserResourceMutation> UserResourceMutations,
    IReadOnlyList<UserResourceLogEntry> UserResourceEntries,
    IReadOnlyList<UserGclMutation> UserGclMutations,        // NEW
    IReadOnlyList<UserPowerMutation> UserPowerMutations);   // NEW
```

### Step 3: Update GlobalMutationWriter Implementation (30 minutes)

**File:** `src/ScreepsDotNet.Engine/Data/GlobalMutations/GlobalMutationWriter.cs`

Add fields and implement methods:
```csharp
internal sealed class GlobalMutationWriter(IGlobalMutationDispatcher dispatcher) : IGlobalMutationWriter
{
    // Existing fields...
    private readonly List<UserGclMutation> _userGclMutations = [];      // NEW
    private readonly List<UserPowerMutation> _userPowerMutations = [];  // NEW

    public void IncrementUserGcl(string userId, int amount)
    {
        if (string.IsNullOrWhiteSpace(userId) || amount <= 0)
            return;
        _userGclMutations.Add(new UserGclMutation(userId, amount));
    }

    public void IncrementUserPower(string userId, double amount)
    {
        if (string.IsNullOrWhiteSpace(userId) || amount <= 0)
            return;
        _userPowerMutations.Add(new UserPowerMutation(userId, amount));
    }

    public void DecrementUserPower(string userId, double amount)
    {
        if (string.IsNullOrWhiteSpace(userId) || amount <= 0)
            return;
        _userPowerMutations.Add(new UserPowerMutation(userId, -amount));
    }

    public async Task FlushAsync(CancellationToken token = default)
    {
        if (/* all lists empty including new ones */) {
            return;
        }

        var batch = new GlobalMutationBatch(
            // ... existing mutations ...
            [.. _userGclMutations],
            [.. _userPowerMutations]);
        await dispatcher.ApplyAsync(batch, token).ConfigureAwait(false);
        Reset();
    }

    public void Reset()
    {
        // ... existing clears ...
        _userGclMutations.Clear();
        _userPowerMutations.Clear();
    }
}
```

### Step 4: Implement Storage Layer Bulk Writer (2 hours)

**File:** `src/ScreepsDotNet.Storage.MongoRedis/BulkWriters/BulkUserStatsWriter.cs`

Mirror `BulkUserMoneyWriter` pattern:
```csharp
internal sealed class BulkUserStatsWriter(IMongoDatabase database)
{
    private readonly IMongoCollection<UserDocument> _users = database.GetCollection<UserDocument>("users");
    private readonly List<WriteModel<UserDocument>> _operations = [];

    public void AddGclIncrement(string userId, int amount)
    {
        // UserDocument.Gcl is Dictionary<string, object?> with keys: "level", "progress", "progressTotal"
        // Node.js: bulkUsers.inc(userId, 'gcl', amount) increments the progress field
        var filter = Builders<UserDocument>.Filter.Eq(u => u.Id, userId);
        var update = Builders<UserDocument>.Update.Inc("gcl.progress", amount);
        _operations.Add(new UpdateOneModel<UserDocument>(filter, update));
    }

    public void AddPowerChange(string userId, double amount)
    {
        // UserDocument.Power is double field
        var filter = Builders<UserDocument>.Filter.Eq(u => u.Id, userId);
        var update = Builders<UserDocument>.Update.Inc(u => u.Power, amount);
        _operations.Add(new UpdateOneModel<UserDocument>(filter, update));
    }

    public async Task FlushAsync(CancellationToken token = default)
    {
        if (_operations.Count == 0)
            return;

        await _users.BulkWriteAsync(_operations, cancellationToken: token).ConfigureAwait(false);
        _operations.Clear();
    }
}
```

**Wire into:** `src/ScreepsDotNet.Driver/GlobalProcessing/GlobalMutationDispatcher.cs`

Update `ApplyAsync` to handle new mutations:
```csharp
public async Task ApplyAsync(GlobalMutationBatch batch, CancellationToken token = default)
{
    // ... existing bulk writers ...
    var statsWriter = new BulkUserStatsWriter(_database);

    // Process GCL mutations
    foreach (var mutation in batch.UserGclMutations)
    {
        statsWriter.AddGclIncrement(mutation.UserId, mutation.GclIncrement);
    }

    // Process power mutations
    foreach (var mutation in batch.UserPowerMutations)
    {
        statsWriter.AddPowerChange(mutation.UserId, mutation.PowerChange);
    }

    // Flush all writers
    await Task.WhenAll(
        // ... existing flushes ...
        statsWriter.FlushAsync(token)
    ).ConfigureAwait(false);
}
```

### Step 5: Add Unit Tests (1 hour)

**File:** `src/ScreepsDotNet.Engine.Tests/Data/GlobalMutations/GlobalMutationWriterTests.cs`

Add 22 tests:
- GCL increment batching (3 tests)
- GCL validation (null userId, zero amount) (3 tests)
- GCL flush and reset (2 tests)
- Power increment batching (2 tests)
- Power decrement batching (2 tests)
- Power validation (null userId, zero amount) (4 tests)
- Power flush and reset (2 tests)
- Mixed GCL + power mutations (2 tests)
- Flush with no mutations (2 tests)

### Step 6: Return to E2.3 and Unblock Features (2-3 hours)

**File:** `src/ScreepsDotNet.Engine/Services/Processors/ControllerIntentStep.cs`

Add GCL tracking to `ProcessUpgrade`:
```csharp
private static void ProcessUpgrade(/* ... */)
{
    // ... existing controller progress calculation ...
    var progressGain = CalculateProgressGain(creep, controller);

    // Apply to controller progress (existing)
    patches[controller.Id].ControllerProgress += progressGain;

    // NEW: Apply to user GCL
    context.GlobalMutationWriter.IncrementUserGcl(creep.UserId, progressGain);

    // ... rest of method ...
}
```

**File:** `src/ScreepsDotNet.Engine/Services/Processors/PowerSpawnIntentStep.cs`

Add power balance tracking to `ProcessPowerSpawn`:
```csharp
private static void ProcessPowerSpawn(/* ... */)
{
    // ... existing power consumption logic ...
    var powerAmount = CalculatePowerAmount(powerSpawn, effect);

    // Consume from power spawn store (existing)
    patches[powerSpawn.Id].Store![ResourceTypes.Power] -= powerAmount;

    // NEW: Increment user power balance
    context.GlobalMutationWriter.IncrementUserPower(powerSpawn.UserId, powerAmount);

    // ... rest of method ...
}
```

**File:** `src/ScreepsDotNet.Engine/Services/Processors/PowerAbilityStep.cs`

Add generateOps case to `ProcessUsePower`:
```csharp
private static void ProcessUsePower(/* ... */)
{
    switch (intent.Power)
    {
        // ... existing cases ...

        case PowerTypes.GenerateOps:  // NEW
            var opsAmount = powerInfo.Effect[powerCreep.Powers[intent.Power] - 1];
            var opsCost = opsAmount;  // 1:1 ratio

            // Deduct from user power balance
            context.GlobalMutationWriter.DecrementUserPower(powerCreep.UserId, opsCost);

            // Add ops to power creep store (handle overflow)
            var currentOps = powerCreep.Store.GetValueOrDefault(ResourceTypes.Ops, 0);
            var maxOps = powerCreep.StoreCapacity;
            var opsToAdd = Math.Min(opsAmount, maxOps - currentOps);
            var overflow = opsAmount - opsToAdd;

            patches[powerCreep.Id].Store![ResourceTypes.Ops] += opsToAdd;

            if (overflow > 0)
            {
                // Create drop at power creep position
                var drop = CreateDrop(powerCreep.Position, ResourceTypes.Ops, overflow);
                context.RoomMutationWriter.InsertObject(drop);
            }
            break;
    }
}
```

---

**Last Updated:** January 21, 2026
**Status:** Not Started - Phase 1 implementation plan complete, ready to execute (6-9 hours total)
