# E2.3 – Room Processor Execution Plan

Status: updated January 17, 2026. This file tracks the granular work required to finish **E2.3 – “Wire engine consumption”** and its dependencies. It supplements `docs/engine/data-model.md` (data contracts) and `src/ScreepsDotNet.Engine/AGENT.md` (high-level milestones).

## What’s Done

- **Driver contracts exposed:** Room/intent snapshots now flow through typed DTOs (`RoomSnapshot`, `RoomObjectSnapshot`, `IntentEnvelope`, etc.). The engine never touches Mongo documents directly.
- **Spawn pipeline:** `SpawnIntentStep` uses helper services for parsing/energy charging/state reading, inserts placeholder creeps, and routes recycle deaths through `ICreepDeathProcessor`.
- **Action-log plumbing:** We now have typed DTOs (`RoomObjectActionLogSnapshot/Patch`) plus mapper support, so steps can emit `healed`, `die`, etc., without raw BSON fiddling.
- **Stats sink integration:** `RoomProcessor` instantiates a `RoomStatsSink` from the driver’s `IHistoryService`. All spawn/recycle paths, the energy charger, and the creep-death processor write to `context.Stats`, ensuring the legacy `stats.inc(...)` metrics are captured in the driver’s room stats updater.
- **Tower intents:** Managed `TowerIntentStep` handles `attack`, `heal`, and `repair`, including range falloff, rampart targeting, stat increments, and unit tests.
- **Shared structure blueprints:** `ScreepsDotNet.Common.Structures.StructureBlueprintRegistry` now centralizes hits, store capacities, decay timers, cooldown metadata, and ownership flags for every buildable structure so the upcoming repair/build step can insert finished objects without duplicating Mongo constants.
- **Driver upsert enrichment:** `RoomMutationDispatcher` now runs every `RoomObjectUpsert` through `RoomObjectBlueprintEnricher`, pulling decay timers (using the current gameTime) and spawn cooldown defaults from the same blueprint data so Mongo never misses these derived fields when the engine emits a new structure.
- **Harvest metadata surfaces:** Driver DTOs expose source energy/invaderHarvested plus mineral and deposit counters (`mineralAmount`, `harvested`, `cooldown`, `cooldownTime`), so upcoming harvest handlers can rely solely on typed fields.
- **Harvest intent pipeline:** `HarvestIntentStep` handles source/mineral/deposit harvesting (range/controller checks, extractor cooldowns, deposit exhaustion) and shares a reusable `ResourceDropHelper` so spawn renewals and harvesters stage drops identically.
- **Room stats telemetry:** `RoomStatsSink` now emits typed `RoomStatsUpdate` payloads, and the driver’s new `RoomStatsPipeline` persists each tick into Mongo (`rooms.stats`) so dashboards and history exporters can consume the new spawn/tombstone/harvest counters.
- **Observability stats export:** `RoomStatsPipeline` fans out updates to registered `IRoomStatsListener`s (currently `RoomStatsTelemetryListener`), letting observability exporters see the new `spawnsCreate`/`spawnsRecycle`/`tombstonesCreated` counters without extra glue code.

## Requirements & Dependency Chain

### 1. Action-log DTO/Patch Plumbing (Plan step 4 prerequisite) ✅
- Add typed action-log fields to the contracts, mapper, and mutation payload so any step can emit `healed`, `attack`, etc.
- This unblocks spawn/tower handlers from touching `_actionLog` directly and lets tests assert the new typed shape.

### 2. Action-log + Stats Integration inside SpawnIntentStep (Plan step 3) ✅
- Update `SpawnIntentStep` to populate the appropriate action-log entries (`healed`, `die`) and increment the richer stats counters (`spawnsRenew`, `spawnsRecycle`, `spawnsCreate`, `tombstonesCreated`).
- Ensure the new `RoomStatsSink` forwards these counters through the driver’s history service so telemetry doesn’t require later edits.

### 3. Finish Create/Renew/Recycle Parity Checks & Tests (Plan step 4) ✅
- Expand unit tests to cover the new action-log patches and stat increments.
- Update AGENT/docs (done in `docs/engine/data-model.md` and this file) to describe the spawn pipeline and shared constants so future sessions pick up the contracts.

### 4. Hook Additional Intent Processors into the Stats Sink (In Progress)
1. **Towers** – ✅ `TowerIntentStep` now deducts energy, applies damage/healing/repairs, and records stats (`energyConstruction` for repairs).  
2. **Creep Repair/Build** – ✅ `CreepBuildRepairStep` now ports the legacy `_repair`/`build` handlers:
   - Recompute repair/build power (including boosts) and apply HP/progress deltas.
   - Deduct energy from the creep, emit `context.Stats.IncrementEnergyConstruction(...)`, and insert finished structures with accurate base stats (hits, store capacities, decay timers).
   - Share structure blueprint helpers so both build completions and future structure-related steps can reuse them.
3. **Harvesting** – ✅ `HarvestIntentStep` now mirrors the legacy handler (sources, minerals, deposits) and reuses the drop/helper/state readers so stats/reporting stay consistent.
   - Support sources, minerals (with extractor cooldown), and deposits.
   - Update creep stores, handle overflow drops, and call `context.Stats.IncrementEnergyHarvested(...)`.

### 5. Telemetry Export Enhancements (In Progress)
1. **Room stats observability fan-out – ✅** RoomStatsPipeline now drives `IRoomStatsListener`s (starting with `RoomStatsTelemetryListener`), so `spawnsCreate`, `spawnsRecycle`, and `tombstonesCreated` reach observability exporters the same tick they’re recorded.
2. Once additional stats (repair/build/harvest) land, verify `RoomStatsUpdater` payloads include them so existing dashboards remain accurate.

### 6. Death Processor Coverage (Ongoing)
1. **Natural expiration ✅** – `CreepLifecycleStep` now calls `ICreepDeathProcessor` when `ticksToLive` reaches zero so age-based deaths share the same drop/stat logic as combat/tower/recycle paths.
2. **Zero-hit cleanup ✅** – Any creep that reaches the lifecycle step with `hits <= 0` now routes through the death processor, ensuring stray removals (e.g., unhandled combat/movement edge cases) still emit drops/tombstones/stats.
3. **User-summoned despawn ✅** – When a `userSummoned` invader shares a room with a real player creep (non-NPC, not the controller owner), the lifecycle step now calls the death processor so their drops/stats follow the same path as legacy `creeps/tick.js`.
4. **Movement crash handlers ✅** –
   - ✅ MovementIntentStep now mirrors the Node resolver’s prioritization rules (pull chains, pulled creep priority, swap detection, safe-mode rampart gating) so contested tiles resolve identically.
   - ✅ `SpawnSpawningStep` mirrors the legacy `_born-creep` helper: it finds an adjacent opening, delays the spawn if any exit exists, and when surrounded performs the legacy spawn-stomp kill via `ICreepDeathProcessor` so hostile blockers die through the shared drop/stat pipeline.
   - ✅ Crash coverage now kills creeps that (a) target out-of-bounds tiles, (b) collide with immovable structures/hostile ramparts/construction sites, (c) have pull chains that enter a fatal tile (both puller and pulled die), or (d) power creeps that attempt to enter portals; MovementIntentStepTests cover these scenarios.
   - ✅ Tile-overflow crashes: MovementIntentStep now crashes every entrant (plus its pull partners) when a fatal tile is targeted—walls, hostile ramparts, blocking structures, or other immovable obstacles—so multi-entrant overflows emit the same drops/tombstones/stats as the legacy crash registry. MovementIntentStepTests cover the multi-entrant fatal scenario.
   - ✅ Inter-room exit transfers: MovementIntentStep now writes `RoomObjectInterRoomPatch` payloads (backed by new driver contract support) whenever a non-NPC creep reaches an accessible edge. The exit-topology descriptor determines the neighbor room/coordinates, so the upcoming global processor can re-home the creep without consulting raw Mongo documents.
   - ✅ Driver rehoming: `MainLoopGlobalProcessor` now uses `IInterRoomTransferProcessor` to consume those patches each tick, update Mongo (`room`, `x`, `y`, `interRoom: null`), and call `ActivateRoomsAsync` for every destination so creeps appear in the next room without a Node shim.
   - ✅ Portal transfers: the engine now reads portal destination metadata from room snapshots, emits the same inter-room patches (including shard targets), and the driver’s transfer processor moves those creeps alongside edge exits. Idle creeps standing on a portal get patched every tick, mirroring `creeps/tick.js` behavior, so no Node hooks remain.
   - Exit-topology crash plan ✅: driver + engine now share a cached `RoomExitTopology` map so MovementIntentStep can burn creeps only when the destination room is missing or closed, matching the legacy resolver. (Filed as “Exit-Topology Crash Plan“ in memory + docs.)
     - ✅ Driver exit-map cache: `RoomExitTopologyProvider` scans accessible rooms + static terrain, counts edge exits, records neighbor rooms + accessibility flags, and invalidates when `UpdateAccessibleRoomsListAsync` runs. The map now flows through `InterRoomSnapshot` ➜ `GlobalSnapshot` ➜ `RoomProcessorContext`.
     - ✅ Engine wiring: `RoomProcessor` attaches the per-room exit descriptor to `RoomProcessorContext`, and `MovementIntentStep` consults it so only exits that lack accessible neighbors trigger a crash. Engine tests now cover the accessible vs. inaccessible edge scenarios.
   - Emit the same stats/action-log entries the Node `_die` helper would (event log `die`, `creepsLost`, tombstones/drops) so telemetry stays aligned. MovementIntentStep already routes every fatal path through `ICreepDeathProcessor`, and the new inter-room transfer pipeline reuses the same sink.

### 7. Remaining Legacy Handler Ports
1. **Tower attack/heal/repair** – ✅ Completed (`TowerIntentStep`).
2. **Creep repair/build** – ✅ Implemented via `CreepBuildRepairStep` (registered in `AddEngineCore`) with blueprint-backed inserts, energy ledger, and stats hooks.
3. **Harvest (sources/minerals/deposits)** – ✅ `HarvestIntentStep` mirrors the Node handler and feeds stats/drop logic.
4. **Controller intents (upgrade/reserve/attack)** – ☐ Need a `ControllerIntentStep` to process `upgradeController`, `reserveController`, and `attackController` intents with RCL-bound energy costs and reservation timers.
5. **Resource I/O intents** – ☐ Add handlers covering `transfer`, `withdraw`, `pickup`, and `drop`, including ownership checks, structure store limits, and action-log/stat integration.
6. **Lab reactions / boosts** – ☐ Port `runReaction`/`boost` flow so labs consume reagents, emit products, and honor cooldowns.
7. **Structure energy routing** – ☐ Implement link/terminal/factory/power-spawn intent steps (energy transfer, market orders, power processing) using the shared blueprint + stats sinks.
8. **Power intents** – ☐ Add power creep ability handling plus power-specific cooldown/stat plumbing once DTOs cover the remaining ability payloads.
9. For every ported step, mirror the legacy `stats.inc(...)` call by invoking the appropriate `context.Stats` method and add unit tests covering both the functional mutation and the stat increment.

## Next Actions (Step-by-Step)
1. **Driver DTO patch – ✅ January 16, 2026:** `RoomObjectSnapshot`, `RoomObjectPatchPayload`, `RoomDocumentFields`, and `RoomContractMapper` now surface source energy/invaderHarvested plus mineral/deposit counters (`mineralAmount`, `harvested`, `cooldown`, `cooldownTime`). The driver tests cover the new round-trips so the engine can consume these metrics without inspecting raw BSON.
2. **Engine intent step – ✅ January 16, 2026:** `HarvestIntentStep` now covers sources, minerals, and deposits, reuses the shared `ResourceDropHelper`, enforces controller/extractor rules, updates stats, and refreshes deposit cooldown/decay timers.
3. **Telemetry/History path – ✅ January 16, 2026:** `RoomStatsSink` now flushes tick-aware payloads, `RoomStatsPipeline` listens for `roomStatsUpdated` events, and `MongoRoomStatsRepository` upserts them into `rooms.stats` for dashboards/logging.
4. **Death coverage expansion:** ensure remaining lethal paths (movement crashes, TTL expiration, etc.) call `ICreepDeathProcessor` so drops/tombstones/stats stay centralized.

## Global Processor Replacement Plan
To retire the remaining Node `global.js`, we’ll stand up a managed equivalent inside the engine:

1. **EngineGlobalProcessor skeleton – ✅ Jan 17 2026:** `ScreepsDotNet.Engine` now exposes `IGlobalProcessor`, `IGlobalProcessorStep`, and `GlobalProcessorContext`, with `EngineGlobalProcessor` resolved via `AddEngineCore()`. It materializes `GlobalState` per tick via `IGlobalStateProvider` and runs any registered global steps (logging a no-op if none exist), giving us the managed hook point the driver can invoke after room processing. Driver-facing loops stay engine-agnostic via the new `IEngineHost` abstraction (defined in driver abstractions and implemented inside `ScreepsDotNet.Engine`).
2. **Transfer consumption – ✅ Jan 17 2026:** `InterRoomTransferStep` (registered as an `IGlobalProcessorStep`) now calls the driver’s `IInterRoomTransferProcessor` using the current `GlobalState.AccessibleRooms`, logs moved creeps, and invalidates `IGlobalStateProvider` when transfers occur. Host wiring still needs to invoke `IGlobalProcessor` each tick, but the managed step logic is ready.
3. **Global intent handlers (In Progress):** after transfers, port the legacy market/power/global-intent hooks, ensuring stats/history updates stay centralized.
   - Prep work (Jan 17 2026): `GlobalProcessorContext` now exposes room-object lookups by type, power-creep dictionaries, and user-intent maps, plus shared `GlobalIntentTypes` constants so the upcoming handlers don’t fall back to raw BSON strings.
   - Power creep delete parity (Jan 17 2026): `PowerCreepIntentStep` now processes `deletePowerCreep` intents (including cancel + experimentation bypass) using the new `GlobalMutationWriter`, so delete-cooldown timestamps and doc removals stay centralized in managed code. `UserState` exposes `PowerExperimentationTime` to match the legacy permission checks.
   - Power creep rename parity (Jan 17 2026): `PowerCreepIntentStep` processes `renamePowerCreep` intents by validating ownership/cooldowns, staging `PowerCreepMutationPatch` updates via the new `GlobalMutationWriter`, and updating the cached power-creep map so subsequent intents see the new name.

Decision (Jan 17 2026): create this processor as a new engine-level service (`EngineGlobalProcessor`) rather than extending the driver’s `MainLoopGlobalProcessor`. Future documentation and code should reference this decision when wiring global steps.
