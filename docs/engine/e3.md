# E3 ‚Äì Intent Gathering & Validation

**Status:** Infrastructure Ready (E3.1 Complete, E3.2 Pending)
**Created:** January 21, 2026
**Last Updated:** January 21, 2026

**Dependencies:**
- E2 (95% complete) - Handler infrastructure in place
- Driver runtime outputs
- Constants for validation rules

**Deliverables:**
- `IIntentPipeline` interface for centralized validation
- Validators for range, resources, permissions, state, schema
- Unit tests mirroring Node.js fixtures
- Integration with Engine processors

---

## Purpose

E3 introduces a **dedicated validation layer** between the Driver's intent gathering and the Engine's intent processing. Currently, validation happens inline within each Engine processor (early returns if invalid). E3 will centralize this validation logic into a reusable pipeline that:

1. **Validates intent structure** - Ensure intents conform to expected schema
2. **Checks range constraints** - Verify creep/structure proximity to targets
3. **Verifies resource availability** - Ensure creep has required resources
4. **Validates permissions** - Check ownership, controller status, safe mode, etc.
5. **Provides diagnostics** - Return actionable error codes (opt-in, for parity silent failures by default)

---

## Node.js Validation Patterns (Baseline)

From analyzing 120 intent processors in `/home/th3b0y/screeps-rewrite/ScreepsNodeJs/engine/src/processor/intents/`:

### Common Validation Checks

**Every intent handler performs these checks inline:**

1. **Object type check** - `if(object.type != 'creep') return;`
2. **Spawning state** - `if(object.spawning) return;`
3. **Target existence** - `if(!target) return;`
4. **Range check** - `if(Math.abs(x1-x2) > range || Math.abs(y1-y2) > range) return;`
5. **Target validity** - `if(!target.hits) return;` (for attackable targets)
6. **Permission checks** - Controller ownership, safe mode, ramparts
7. **Resource checks** - Energy/mineral availability in stores

### Example: Node.js Attack Intent

```javascript
// ScreepsNodeJs/engine/src/processor/intents/creeps/attack.js
module.exports = function(object, intent, scope) {
    if(object.type != 'creep') return;               // ‚ùå Not a creep
    if(object.spawning) return;                       // ‚ùå Still spawning

    var target = roomObjects[intent.id];
    if(!target || target == object) return;          // ‚ùå Invalid target
    if(Math.abs(target.x - object.x) > 1 ||           // ‚ùå Out of range
       Math.abs(target.y - object.y) > 1) return;
    if(!target.hits) return;                          // ‚ùå No hits property
    if(roomController && roomController.user != object.user &&  // ‚ùå SafeMode
       roomController.safeMode > gameTime) return;

    // ‚úÖ Valid - apply damage
}
```

### .NET Engine Current State

**E2 handlers replicate Node.js inline validation:**

```csharp
// src/ScreepsDotNet.Engine/Processors/Steps/HarvestIntentStep.cs
private static void ProcessHarvest(...)
{
    if (!record.Payload.TryGetStringProperty("id", out var targetId)) return;
    if (!context.State.Objects.TryGetValue(targetId, out var target)) return;

    var distance = Math.Max(Math.Abs(target.X - creep.X), Math.Abs(target.Y - creep.Y));
    if (distance > 1) return; // ‚ùå Duplicated range logic

    // ‚úÖ Valid - execute harvest
}
```

---

## Planned Components

### Core Infrastructure ‚úÖ (E3.1 Complete)

| Component | Status | Tests | Description |
|-----------|--------|-------|-------------|
| `IIntentPipeline` | ‚úÖ | TBD | Main validation pipeline interface |
| `IIntentValidator` | ‚úÖ | TBD | Base validator interface |
| `ValidationResult` | ‚úÖ | - | Validation output (IsValid, ErrorCode) |
| `ValidationErrorCode` | ‚úÖ | - | Error code enum (45 error codes) |
| `ValidationRanges` | ‚úÖ | - | Range requirements by intent (35 intents, Chebyshev helper) |
| `ResourceRequirements` | ‚úÖ | - | Resource costs and valid types (120+ resources) |
| `PermissionRules` | ‚úÖ | - | Ownership and access rules (15 permission rules) |
| `StateRequirements` | ‚úÖ | - | Object state rules (10 state rules) |
| `ValidationServiceCollectionExtensions` | ‚úÖ | - | DI registration for pipeline + validators |

**Sub-total:** 0/34 tests

### Validators üìã (E3.2 - Infrastructure Ready)

| Validator | Status | Tests | Validation Types |
|-----------|--------|-------|------------------|
| `RangeValidator` | üìã | 0/30 | Chebyshev distance checks for all intent types |
| `ResourceValidator` | üìã | 0/20 | Store availability, capacity checks |
| `PermissionValidator` | üìã | 0/20 | Ownership, controller, safe mode, ramparts |
| `StateValidator` | üìã | 0/15 | Spawning, dead/destroyed, existence checks |
| `SchemaValidator` | üìã | 0/15 | Payload structure, required fields, types |

**Sub-total:** 0/100 tests (infrastructure ready - see `e3.2.md` for detailed implementation plan)

### Constants & Rules ‚úÖ (E3.1 Complete)

| Component | Status | Count | Description |
|-----------|--------|-------|-------------|
| `ValidationRanges` | ‚úÖ | 35 intents | Range by intent type (attack: 1, rangedAttack: 3, etc.) + Chebyshev helper |
| `ResourceRequirements` | ‚úÖ | 120+ resources | All resource types, lab/tower/power costs |
| `PermissionRules` | ‚úÖ | 15 rules | Controller ownership, safe mode, ramparts |
| `StateRequirements` | ‚úÖ | 10 rules | Valid object states for actions |

**Sub-total:** ‚úÖ 180+ constants/rules complete (ready for validator implementation)

### Integration üìã

| Component | Status | Tests | Description |
|-----------|--------|-------|-------------|
| `RoomProcessor` integration | üìã | 0/10 | Wire `IIntentPipeline` into tick flow |
| Remove inline validation | üìã | E2 240 | Clean up duplicated checks from E2 handlers |
| Pre-validation hook | üìã | 0/5 | Call validators before intent execution |
| Diagnostics pipeline | üìã | 0/10 | Metrics, error tracking, logging |

**Sub-total:** 0/25 tests (+ E2 regression: 240 tests)

---

## Validation Rules Reference

### Range Requirements (Chebyshev Distance)

**Range 1 (Adjacent):**
- Attack, Harvest, Build, Repair, Dismantle
- Transfer, Withdraw, Pickup, Drop
- Heal (melee), GenerateSafeMode, ClaimController

**Range 3:**
- RangedAttack, RangedHeal, UpgradeController
- AttackController, ReserveController, SignController

**Special Cases:**
- RangedMassAttack: Range 3 (center) + Range 1 (splash)
- Pull: Range 1 (must be adjacent)
- Towers: Range 50 (full room), with falloff starting at range 5

### Resource Requirements

**Energy Consumers:**
- Build: `bodyParts(WORK) * BUILD_POWER * 0.2` energy per body part
- Repair: `bodyParts(WORK) * REPAIR_POWER * REPAIR_COST` energy
- Upgrade: `bodyParts(WORK) * 1` energy (boosted: up to 2x with GH-series)
- Spawn: Pre-calculated cost based on body parts

**Mineral/Commodity Consumers:**
- Lab boost: 30 mineral + 20 energy per body part
- Lab unboost: 15 mineral return (no energy)
- Lab reaction: Component minerals (amounts from reaction formulas)
- Factory produce: Component commodities (amounts from recipes)

**Power Consumers:**
- Power spawn: 1 power per tick
- Power creep abilities: Power cost by ability level (from PowerConstants)

### Permission Requirements

**Controller Ownership:**
- UpgradeController: Owned by user OR reserved by user
- AttackController: NOT owned by user (or break reservation)
- ReserveController: NOT owned by anyone
- ClaimController: Neutral or expired reservation

**Safe Mode:**
- Blocks all attack intents when `controller.safeMode > gameTime`
- Applies only to different users (owner can still attack own creeps)
- Does NOT block dismantle, claiming, or reservation

**Ramparts:**
- Block access to non-owners UNLESS rampart is public
- Creeps cannot attack structures behind enemy ramparts (attack rampart instead)
- Owner/allies can pass through

### State Requirements

**Actor (Creep) State:**
- NOT spawning (`creep.spawning === false`)
- Alive (`creep.hits > 0`)
- Exists in room objects (`roomObjects[creepId]`)

**Target State:**
- Exists (`target !== undefined`)
- Not self (`target !== actor`)
- Has required properties (e.g., `target.hits` for attackable, `target.store` for transferable)
- Appropriate type (can't attack a source, can't harvest a creep, etc.)

---

## Code Structure

**Planned Directory Layout:**
```
src/ScreepsDotNet.Engine/Validation/
‚îú‚îÄ‚îÄ IIntentPipeline.cs                     # Main pipeline interface
‚îú‚îÄ‚îÄ IntentValidationPipeline.cs            # Default implementation
‚îú‚îÄ‚îÄ Validators/
‚îÇ   ‚îú‚îÄ‚îÄ IIntentValidator.cs                # Base validator interface
‚îÇ   ‚îú‚îÄ‚îÄ RangeValidator.cs                  # Distance checks
‚îÇ   ‚îú‚îÄ‚îÄ ResourceValidator.cs               # Resource availability
‚îÇ   ‚îú‚îÄ‚îÄ PermissionValidator.cs             # Ownership/access checks
‚îÇ   ‚îú‚îÄ‚îÄ StateValidator.cs                  # Object state checks
‚îÇ   ‚îú‚îÄ‚îÄ SchemaValidator.cs                 # Payload structure
‚îÇ   ‚îî‚îÄ‚îÄ ValidatorRegistry.cs               # Intent type ‚Üí validator mapping
‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îú‚îÄ‚îÄ IntentValidationResult.cs          # Validation output
‚îÇ   ‚îú‚îÄ‚îÄ ValidatedIntent.cs                 # Valid intent envelope
‚îÇ   ‚îú‚îÄ‚îÄ RejectedIntent.cs                  # Rejected with reason
‚îÇ   ‚îî‚îÄ‚îÄ ValidationStatistics.cs            # Metrics
‚îú‚îÄ‚îÄ Constants/
‚îÇ   ‚îú‚îÄ‚îÄ ValidationRanges.cs                # Range by intent type
‚îÇ   ‚îú‚îÄ‚îÄ ResourceRequirements.cs            # Energy/mineral costs
‚îÇ   ‚îú‚îÄ‚îÄ PermissionRules.cs                 # Access control rules
‚îÇ   ‚îî‚îÄ‚îÄ ValidationErrorCode.cs             # Error codes enum
‚îî‚îÄ‚îÄ ScreepsDotNet.Engine.Tests/Validation/
    ‚îú‚îÄ‚îÄ IntentValidationPipelineTests.cs   # Pipeline tests
    ‚îî‚îÄ‚îÄ Validators/
        ‚îú‚îÄ‚îÄ RangeValidatorTests.cs
        ‚îú‚îÄ‚îÄ ResourceValidatorTests.cs
        ‚îú‚îÄ‚îÄ PermissionValidatorTests.cs
        ‚îú‚îÄ‚îÄ StateValidatorTests.cs
        ‚îî‚îÄ‚îÄ SchemaValidatorTests.cs
```

---

## Implementation Roadmap

### E3.1: Core Infrastructure üìã

**Goal:** Foundational interfaces and pipeline

**Deliverables:**
- [ ] `IIntentPipeline` interface
- [ ] `IntentValidationResult`, `ValidatedIntent`, `RejectedIntent` DTOs
- [ ] `ValidationErrorCode` enum (20-30 error types)
- [ ] `IntentValidationPipeline` implementation
- [ ] `IIntentValidator` base interface
- [ ] `ValidatorRegistry` for intent type mapping

**Tests:** 34 tests (see Planned Components table)

**Effort:** 3-4 hours

**Exit Criteria:**
- Pipeline can register and invoke validators
- Results correctly categorize valid/rejected intents
- DI registration works

---

### E3.2: Validator Implementation üìã

**Goal:** Implement all 5 core validators

**Status:** Not Started (Detailed tracking in `e3.2.md`)

**Deliverables:**
- [ ] E3.2.1: Range Validator (30 tests, 3-4h)
- [ ] E3.2.2: Resource Validator (20 tests, 2-3h)
- [ ] E3.2.3: Permission Validator (20 tests, 3-4h)
- [ ] E3.2.4: State Validator (15 tests, 2-3h)
- [ ] E3.2.5: Schema Validator (15 tests, 2-3h)

**Tests:** 100 tests total

**Effort:** 12-17 hours

**Details:** See **`e3.2.md`** for:
- Detailed progress tracking tables (Validator √ó Intent Type matrix)
- Validation rules per intent type (35 intents √ó 5 validators)
- Test coverage breakdown (unit, integration, parity)
- Constants reference (ValidationRanges, ResourceRequirements, etc.)
- Parity validation strategy (Node.js baseline comparison)
- Code examples and implementation checklists

**Exit Criteria:**
- [ ] All 5 validators implemented and registered in DI
- [ ] 100/100 tests passing
- [ ] All validation constants defined
- [ ] Parity tests pass (Node.js vs .NET validation results match)
- [ ] Code review complete

---

### E3.3: Integration üìã

**Goal:** Wire validators into Engine processors

**Deliverables:**
- [ ] Add `IIntentPipeline` to `RoomProcessor`
- [ ] Call pipeline before intent processing
- [ ] Remove inline validation from E2 handlers (all 11 families)
- [ ] Update handlers to trust pre-validated intents
- [ ] Regression tests

**Tests:** 25 new + 240 E2 regression

**Effort:** 5-7 hours

**Exit Criteria:**
- All E2 tests pass (240/240)
- No duplication of validation logic
- Handlers are cleaner (fewer early returns)

---

### E3.4: Observability üìã

**Goal:** Metrics and diagnostics

**Deliverables:**
- [ ] `ValidationStatistics` tracking
- [ ] Metrics: valid/rejected counts by type
- [ ] Error code distribution
- [ ] Diagnostic logging for rejections
- [ ] Integration with Engine telemetry

**Tests:** 10 tests

**Effort:** 2-3 hours

---

## Total Estimates

**Tests:** 169 new + 240 regression = 409 total
**Effort:** 22-31 hours (split across 4 phases)
**Parity:** Silent failures (match Node.js), opt-in diagnostics later

---

## Test Coverage Summary

**Target:** 169 new tests + 240 E2 regression = 409 total

| Phase | Component | Tests | Status |
|-------|-----------|-------|--------|
| E3.1 | Core Infrastructure | 34 | üìã Pending |
| E3.2.1 | Range Validator | 30 | üìã Pending |
| E3.2.2 | Resource Validator | 20 | üìã Pending |
| E3.2.3 | Permission Validator | 20 | üìã Pending |
| E3.2.4 | State Validator | 15 | üìã Pending |
| E3.2.5 | Schema Validator | 15 | üìã Pending |
| E3.3 | Integration | 25 | üìã Pending |
| E3.4 | Observability | 10 | üìã Pending |
| **E3 Total** | **New Tests** | **169** | **üìã 0/169** |
| **E2 Regression** | **Existing Tests** | **240** | **‚úÖ 240/240** |
| **Grand Total** | **All Tests** | **409** | **240/409 (58%)** |

---

## Design Decisions

### 1. Error Reporting: Silent Failures (Node.js Parity)

**Decision:** Match Node.js behavior - validation failures are silent (no error codes to user console)

**Rationale:**
- E7 parity validation requires identical behavior
- Adding error reporting later is easier than removing it
- Diagnostics can be opt-in feature (E3.4 or later)

**Future:** E8 observability may add verbose validation mode for debugging

### 2. Validation Timing: Pre-Execution

**Decision:** Validate all intents before intent processing begins

**Rationale:**
- Consistent validation order (no processor-dependent sequencing)
- Easier to test (validators isolated from processors)
- Cleaner processor code (no duplicated validation)

**Trade-off:** Adds ~5ms per room (acceptable overhead)

### 3. Scope: Room-Level Intents Only

**Decision:** E3 validates room-scoped intents; global intents (market, power creeps) remain in E5 processors

**Rationale:**
- Global intents are already separate pipeline (`EngineGlobalProcessor`)
- Market validation has different rules (cross-room, asynchronous)
- Keeps E3 focused and testable

**Future:** E5 may add `IIntentPipeline` for global intents if patterns emerge

### 4. Extensibility: Interface-Based, Defer Mods

**Decision:** Design with `IIntentValidator` interfaces, implement core validators first, defer mod support

**Rationale:**
- Interface-based design allows future extensibility
- Core Screeps validation is well-defined (120 Node.js handlers)
- Mod support can be added in E6/E7 without breaking changes

**Future:** `ValidatorRegistry.RegisterCustomValidator(intentType, validator)` for mods

---

## Deferred Features

### Non-Parity-Critical (Future Work)

These features are not required for E7 parity validation and can be implemented post-E3:

#### 1. Error Code Visibility (User Console)

**Impact:** Debugging/UX only, not simulation-critical

**What's needed:**
- Add `IDriverConfig.VerboseValidation` flag
- Return validation errors in runtime result
- Display error codes in user console

**Scope:** Post-E3 (possibly E8 observability)

**Effort:** 2-3 hours

#### 2. Custom Validator Registration (Mods)

**Impact:** Mod support only

**What's needed:**
- `ValidatorRegistry.RegisterCustomValidator(intentType, validator)`
- Allow mods to inject custom validation logic
- Tests for custom validator chaining

**Scope:** Post-E3 (possibly E6 when mod support is added)

**Effort:** 3-4 hours

#### 3. Validation Caching

**Impact:** Performance optimization only

**What's needed:**
- Cache validation results for repeated intents (same tick)
- Invalidate cache when room state changes
- Benchmark to verify improvement

**Scope:** Post-E3 (if profiling shows validation overhead >5ms)

**Effort:** 4-6 hours

#### 4. Global Intent Validation Pipeline

**Impact:** E5 feature, not E3

**What's needed:**
- `IIntentPipeline` for global intents (market, power creeps)
- Market-specific validators (price, amount, resource type)
- Power creep validators (power availability, level requirements)

**Scope:** E5 (Global Systems)

**Effort:** 6-8 hours

---

## Success Criteria

### Functional Requirements ‚úÖ/‚ùå

- [ ] All room-level intents validated before processing
- [ ] Validation results categorize valid/rejected intents
- [ ] All E2 tests continue passing (240/240)
- [ ] Parity with Node.js validation (silent failures by default)
- [ ] Validators cover 35+ intent types (creep actions, structure actions)
- [ ] Error codes defined for all rejection reasons (20-30 codes)

### Non-Functional Requirements ‚úÖ/‚ùå

- [ ] Validation overhead <5ms per room per tick (typical: 10-50 intents)
- [ ] 100% test coverage for validators (169 new tests)
- [ ] Zero duplication: processors don't validate (E2 handlers cleaned up)
- [ ] Extensible design: `IIntentValidator` supports future validators

### Documentation ‚úÖ/‚ùå

- [ ] `e3.md` tracking document (this file) maintained during implementation
- [ ] Update `roadmap.md` with E3 progress as phases complete
- [ ] API documentation for `IIntentPipeline` and `IIntentValidator`
- [ ] Code comments explaining validation rules and constants

---

## Risks & Mitigations

### Risk: Performance Overhead

**Likelihood:** Medium | **Impact:** Medium

**Concern:** Pre-validating all intents may add latency to tick processing

**Mitigation:**
- Benchmark with realistic loads (100 rooms, 10-50 intents/room)
- Target <5ms per room (0.5% of typical 1-second tick)
- Optimize hot paths (range checks, object lookups)
- Profile and optimize if overhead exceeds target

**Fallback:** If >10ms overhead, revert to just-in-time validation

### Risk: Parity Divergence

**Likelihood:** Medium | **Impact:** High

**Concern:** Centralized validation might differ subtly from Node.js inline checks

**Mitigation:**
- Systematically compare all 120 Node.js intent handlers
- Write cross-engine parity tests (Node.js fixture ‚Üí .NET validation)
- Document intentional divergences (e.g., better error messages)
- Run E7 parity suite frequently during E3 implementation

**Metric:** Zero unintentional divergences detected by E7 suite

### Risk: Incomplete Validation Rules

**Likelihood:** Low | **Impact:** High

**Concern:** Missing edge cases that Node.js handles inline (e.g., rampart blocking, spawn queues)

**Mitigation:**
- Create checklist of all validation types from Node.js review
- Test coverage includes edge cases (e.g., self-attack, neutral targets)
- Add regression tests for bugs found during E3 implementation
- Review with Node.js engine expert before E3.3 integration

**Metric:** 100% of Node.js validation rules covered by tests

### Risk: Integration Breakage

**Likelihood:** Low | **Impact:** Medium

**Concern:** Removing inline validation from E2 handlers breaks existing tests

**Mitigation:**
- Keep E2 tests passing throughout E3.3 integration
- Incremental rollout: validate one handler family at a time
- Feature flag to enable/disable E3 pipeline during development
- Rollback plan: revert integration, keep validators for future use

**Metric:** All 240 E2 tests pass after E3.3

---

## Dependencies & Integration Points

### Upstream Dependencies (Required Before E3)

| Dependency | Status | Impact if Missing |
|------------|--------|-------------------|
| **E2 Handler Infrastructure** | ‚úÖ 95% | Can't integrate validators without processors |
| **Driver `RoomIntentSnapshot` DTOs** | ‚úÖ Complete | No intent data to validate |
| **Engine `RoomStateSnapshot`** | ‚úÖ Complete | Can't check ranges, ownership, resources |
| **Common Constants (ranges, costs)** | ‚ö†Ô∏è Partial | Need to define `ValidationRanges` constants |

### Downstream Dependencies (Blocked by E3)

| Dependency | Blocker | Impact |
|------------|---------|--------|
| **E4 (Simulation Kernel)** | E3 incomplete | E4 will consume pre-validated intents |
| **E7 (Parity Validation)** | E3 incomplete | E7 requires E3 validation to match Node.js |
| **E6 (Orchestration)** | E3.4 metrics | May expose validation metrics |

### Cross-Subsystem Contracts

**Engine ‚Üî Driver:**
- **Reads:** `RoomIntentSnapshot` (intent payloads from runtime)
- **Reads:** `RoomStateSnapshot` (room objects, terrain, users)
- **Writes:** Validation metrics to telemetry (future E3.4)

**Engine ‚Üî Storage:**
- **Reads:** NONE (E3 is read-only, no DB access)
- **Writes:** NONE (validation doesn't persist anything)

---

## Next Steps

### Phase 1: Exploration (Before Implementation)

1. **Survey Node.js validation patterns:**
   - [ ] Review all 120 Node.js intent handlers
   - [ ] Document validation checks by category (range, resource, permission, state)
   - [ ] Extract validation constants (ranges, costs) into checklist
   - [ ] Identify edge cases (ramparts, safe mode, portals, etc.)

2. **Design validation architecture:**
   - [ ] Finalize `IIntentValidator` interface signature
   - [ ] Plan validator chaining/composition strategy
   - [ ] Design `ValidationErrorCode` taxonomy (20-30 codes)
   - [ ] Sketch pipeline flow diagram

3. **Create validation constants:**
   - [ ] Define `ValidationRanges` (35 intent types)
   - [ ] Define `ResourceRequirements` (energy/mineral costs)
   - [ ] Define `PermissionRules` (controller, safe mode, ramparts)
   - [ ] Define `StateRequirements` (spawning, alive, exists)

### Phase 2: Implementation (E3.1 ‚Üí E3.4)

1. **E3.1 - Core Infrastructure:**
   - Implement `IIntentPipeline`, `IntentValidationPipeline`
   - Write 34 tests for pipeline logic
   - Register in DI

2. **E3.2 - Validators (5 components):**
   - Implement all 5 validators in order: Range ‚Üí Resource ‚Üí Permission ‚Üí State ‚Üí Schema
   - Write 100 tests total
   - Validate against Node.js fixtures

3. **E3.3 - Integration:**
   - Wire into `RoomProcessor`
   - Remove inline validation from E2 handlers
   - Verify all 240 E2 tests pass

4. **E3.4 - Observability:**
   - Add validation metrics
   - Integrate with telemetry
   - Document API

### Phase 3: Validation (Before Marking Complete)

1. **Parity Check:**
   - [ ] Compare .NET validation results with Node.js for all 35 intent types
   - [ ] Document any intentional divergences
   - [ ] Run E7 parity suite (when available)

2. **Performance Benchmark:**
   - [ ] Measure validation overhead (target <5ms per room)
   - [ ] Profile hot paths (range checks, object lookups)
   - [ ] Optimize if needed

3. **Documentation:**
   - [ ] Update this `e3.md` with final test counts
   - [ ] Update `roadmap.md` with E3 completion
   - [ ] Add API docs for `IIntentPipeline`

---

## Implementation Examples

### Example 1: Range Validator

**Node.js Baseline (attack.js):**
```javascript
if(Math.abs(target.x - object.x) > 1 || Math.abs(target.y - object.y) > 1) {
    return; // Out of range
}
```

**E3 .NET Implementation:**
```csharp
namespace ScreepsDotNet.Engine.Validation.Validators;

public class RangeValidator : IIntentValidator
{
    public ValidationResult Validate(ValidatedIntent intent, RoomStateSnapshot state)
    {
        var requiredRange = ValidationRanges.GetRange(intent.IntentType);
        var distance = CalculateChebyshevDistance(intent.Actor, intent.Target);

        if (distance > requiredRange)
            return ValidationResult.Rejected(ValidationErrorCode.NotInRange);

        return ValidationResult.Valid();
    }

    private static int CalculateChebyshevDistance(RoomObjectSnapshot a, RoomObjectSnapshot b)
        => Math.Max(Math.Abs(a.X - b.X), Math.Abs(a.Y - b.Y));
}
```

**Test:**
```csharp
[Fact]
public void Validate_AttackIntent_OutOfRange_ReturnsRejected()
{
    // Arrange
    var actor = new RoomObjectSnapshot { X = 10, Y = 10 };
    var target = new RoomObjectSnapshot { X = 15, Y = 15 }; // Distance 5 (> 1)
    var intent = new ValidatedIntent("attack", actor, target);

    // Act
    var result = rangeValidator.Validate(intent, state);

    // Assert
    Assert.False(result.IsValid);
    Assert.Equal(ValidationErrorCode.NotInRange, result.ErrorCode);
}
```

### Example 2: Permission Validator (SafeMode)

**Node.js Baseline (attack.js):**
```javascript
if(roomController && roomController.user != object.user &&
   roomController.safeMode > gameTime) {
    return; // SafeMode blocks attack
}
```

**E3 .NET Implementation:**
```csharp
public class PermissionValidator : IIntentValidator
{
    public ValidationResult Validate(ValidatedIntent intent, RoomStateSnapshot state)
    {
        if (intent.IntentType == IntentTypes.Attack || intent.IntentType == IntentTypes.RangedAttack)
        {
            var controller = state.Controller;
            if (controller is not null &&
                controller.UserId != intent.Actor.UserId &&
                controller.SafeMode > state.GameTime)
            {
                return ValidationResult.Rejected(ValidationErrorCode.SafeModeActive);
            }
        }

        return ValidationResult.Valid();
    }
}
```

---

## References

### Implementation Documents
- **Roadmap:** `docs/engine/roadmap.md` - E1-E8 milestones
- **E2 Tracking:** `docs/engine/e2.md` - Handler implementation status
- **E3 Tracking:** `docs/engine/e3.md` - This document (main E3 plan)
- **E3.2 Tracking:** `docs/engine/e3.2.md` - Detailed validator implementation tracking
- **E5 Blockers:** `docs/engine/e5.md` - Global systems requirements
- **Data Model:** `docs/engine/data-model.md` - Engine data contracts

### Source Code References
- **Node.js Engine:** `/home/th3b0y/screeps-rewrite/ScreepsNodeJs/engine/src/processor/intents/`
  - 120 intent processors with inline validation
  - Creep actions: `creeps/` directory (35 intent types)
  - Structure actions: `spawns/`, `towers/`, `labs/`, etc.
- **Driver Contracts:** `src/ScreepsDotNet.Driver/Contracts/`
  - `RoomIntentSnapshot.cs` - Intent DTOs from runtime
  - `RoomStateSnapshot.cs` - Room state for validation context
- **Engine Processors:** `src/ScreepsDotNet.Engine/Processors/`
  - `Steps/` - E2 handlers with inline validation (to be refactored)
  - `Helpers/` - Shared validation logic (e.g., range checks)
- **Common Constants:** `src/ScreepsDotNet.Common/Constants/`
  - `ScreepsGameConstants.cs` - Game constants (needs validation ranges)
  - `ResourceTypes.cs` - Resource type constants
  - `RoomObjectTypes.cs` - Object type constants

### External References
- [Screeps API Documentation](https://docs.screeps.com/api/) - Official API reference
- [Screeps Game Constants](https://docs.screeps.com/api/#Game-constants) - Range/cost constants
- Node.js private server source - Validation baseline for parity

---

## Summary

**E3: Intent Gathering & Validation** introduces a centralized validation layer that will:

‚úÖ **Replace** inline validation in E2 processors with a reusable pipeline
‚úÖ **Validate** 35+ intent types across 5 categories (range, resource, permission, state, schema)
‚úÖ **Maintain** parity with Node.js engine (silent failures by default)
‚úÖ **Provide** foundation for E4 simulation kernel and E7 parity validation
‚úÖ **Enable** future diagnostics and error reporting (E3.4/E8)

**Effort:** 22-31 hours across 4 phases
**Tests:** 169 new + 240 E2 regression = 409 total
**Deliverable:** `docs/engine/e3.md` (this document, copied from plan file)

**Critical Path:**
1. E3.1: Core infrastructure (pipeline, interfaces, DTOs)
2. E3.2: Validators (range, resource, permission, state, schema)
3. E3.3: Integration (wire into RoomProcessor, clean E2 handlers)
4. E3.4: Observability (metrics, diagnostics)

**Blockers:** None (E2 95% complete is sufficient)
**Risks:** Performance overhead (<5ms target), parity divergence (E7 validation)
**Next:** User approval ‚Üí E3.1 implementation

---

**Last Updated:** January 21, 2026 (Initial planning draft)
**File Location:** This plan will be copied to `/home/th3b0y/screeps-rewrite/ScreepsDotNet/docs/engine/e3.md` upon execution
