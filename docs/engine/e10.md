# E10: Full Parity Test Coverage

**Status:** üìã In Progress
**Estimated Effort:** 20-30 hours total
**Current State:** 17 parity tests passing (7 programmatic + 10 keeper AI), 4 JSON fixtures, 916/916 total tests passing
**Last Updated:** January 22, 2026

---

## Executive Summary

Expand parity test coverage from 4 fixtures to 25-30 fixtures, covering all implemented Engine processors. This will validate 100% behavioral parity with the official Node.js Screeps engine for E1-E6 features.

**Why This Matters:**
- Detects behavioral divergences early (before production)
- Validates .NET implementation correctness against official engine
- Provides regression protection for future changes
- Enables confident deployment of .NET engine

**Success Criteria:**
- ‚úÖ 25-30 JSON fixtures covering all major intent types
- ‚úÖ 25-30 Node.js comparison parity tests
- ‚úÖ All tests passing (100% parity achieved)
- ‚úÖ CI/CD workflow automated
- ‚úÖ Documentation complete

---

## Phase 0: Keeper AI Parity Tests - ‚úÖ COMPLETE (January 22, 2026)

**Status:** 10 parity tests implemented and passing

**Approach:** Programmatic tests using `ParityFixtureBuilder` (not JSON fixtures)
- Keeper AI uses direct mutations, not player intents
- Programmatic approach provides type safety and faster iteration
- Tests validate target assignment, combat priority, path caching, invader filtering, and multi-action execution

**Test Count:** +10 parity tests (Engine.Tests: 562 ‚Üí 572)

**Rationale for Programmatic Tests:**
- JSON fixtures are for player intent testing (harvest, attack, transfer, etc.)
- Programmatic tests are for AI/passive systems (keeper AI, regeneration, decay)
- Hybrid approach maximizes coverage with minimal maintenance

**Cross-Reference:** See `docs/engine/e9.md` for complete keeper AI implementation details

---

## Phase 1: Core Fixtures (Priority 1) - 12-15 hours

### Goal
Add 15-20 high-value fixtures covering core gameplay mechanics.

### 1.1 Combat Fixtures (4 fixtures, ~2 hours)

**File:** `src/ScreepsDotNet.Engine.Tests/Parity/Fixtures/combat_attack.json`
```json
{
  "gameTime": 100,
  "room": "W1N1",
  "objects": [
    {
      "_id": "creep1",
      "type": "creep",
      "x": 25,
      "y": 25,
      "user": "user1",
      "body": [
        {"type": "attack", "hits": 100},
        {"type": "move", "hits": 100}
      ],
      "hits": 200,
      "hitsMax": 200
    },
    {
      "_id": "creep2",
      "type": "creep",
      "x": 26,
      "y": 25,
      "user": "user2",
      "body": [{"type": "move", "hits": 100}],
      "hits": 100,
      "hitsMax": 100
    }
  ],
  "intents": {
    "user1": {
      "creep1": [
        {"intent": "attack", "id": "creep2"}
      ]
    }
  },
  "users": {
    "user1": {...},
    "user2": {...}
  }
}
```

**Fixtures to create:**
1. `combat_attack.json` - melee attack (attack intent)
2. `combat_ranged.json` - ranged attack/heal (rangedAttack, rangedHeal)
3. `combat_heal.json` - heal intent (heal)
4. `combat_dismantle.json` - dismantle structure (dismantle)

**Tests to add (EndToEndParityTests.cs):**
```csharp
[Fact]
public async Task Combat_Attack_MatchesNodeJsEngine()
{
    var fixturePath = Path.Combine("Parity", "Fixtures", "combat_attack.json");
    var state = await JsonFixtureLoader.LoadFromFileAsync(fixturePath, TestContext.Current.CancellationToken);

    var dotnetOutput = await ParityTestRunner.RunAsync(state, TestContext.Current.CancellationToken);
    var nodejsOutput = await NodeJsHarnessRunner.RunFixtureAsync(fixturePath, prerequisites.HarnessDirectory, mongoFixture.ConnectionString, TestContext.Current.CancellationToken);

    var comparison = Comparison.ParityComparator.Compare(dotnetOutput, nodejsOutput);
    if (comparison.HasDivergences) {
        Assert.Fail(Comparison.DivergenceReporter.FormatReport(comparison, "combat_attack.json"));
    }
}
```

**Expected divergences:** None (CombatResolutionStep is fully implemented)

---

### 1.2 Resource Management Fixtures (5 fixtures, ~2.5 hours)

**Fixtures:**
1. `drop_pickup.json` - drop + pickup intents in sequence
   - Creep drops energy at position
   - Another creep picks it up
   - Tests: Resource object creation, removal

2. `withdraw_container.json` - withdraw from container
   - Container with energy
   - Creep withdraws energy
   - Tests: Container store update, creep store update

3. `transfer_tower.json` - transfer to tower
   - Creep with energy
   - Tower with partial energy
   - Tests: Energy transfer, capacity limits

4. `lab_boost.json` - boostCreep intent
   - Lab with mineral (UH - attack boost)
   - Creep with attack body part
   - Tests: Mineral consumption, boost application

5. `lab_unboost.json` - unboostCreep intent
   - Creep with boosts
   - Lab to receive minerals
   - Tests: Boost removal, mineral return

**Pattern:**
```json
{
  "gameTime": 100,
  "room": "W1N1",
  "objects": [
    {
      "_id": "creep1",
      "type": "creep",
      "x": 25,
      "y": 25,
      "user": "user1",
      "body": [
        {"type": "carry", "hits": 100},
        {"type": "move", "hits": 100}
      ],
      "store": {"energy": 50},
      "storeCapacity": 50
    },
    {
      "_id": "resource1",
      "type": "energy",
      "x": 26,
      "y": 25,
      "resourceType": "energy",
      "amount": 100
    }
  ],
  "intents": {
    "user1": {
      "creep1": [
        {"intent": "pickup", "id": "resource1"}
      ]
    }
  }
}
```

---

### 1.3 Movement Fixtures (3 fixtures, ~1.5 hours)

**Fixtures:**
1. `movement_basic.json` - move intent with fatigue calculation
   - Creep with move body parts
   - Tests: Position update, fatigue calculation

2. `movement_pull.json` - pull intent (chain movement)
   - Two creeps, one pulling the other
   - Tests: Both creeps move, fatigue on both

3. `movement_say.json` - say intent (action log)
   - Creep says message
   - Tests: Action log recording

**Key properties for movement:**
- `fatigue` (current fatigue level)
- Body parts (move, carry with resources affect fatigue)
- Room boundaries (0-49)

---

### 1.4 Structure Fixtures (6 fixtures, ~3 hours)

**Fixtures:**
1. `build_construction.json` - build construction site
   - Creep with energy
   - Construction site (type: spawn, progress: 0, progressTotal: 5000)
   - Tests: Progress increase, energy consumption

2. `repair_structure.json` - repair damaged structure
   - Creep with energy
   - Damaged spawn (hits: 3000, hitsMax: 5000)
   - Tests: Hits increase, energy consumption

3. `tower_attack.json` - tower attack
   - Tower with energy
   - Enemy creep
   - Tests: Damage calculation, range falloff, energy consumption

4. `tower_heal.json` - tower heal
   - Tower with energy
   - Damaged friendly creep
   - Tests: Healing calculation, range falloff

5. `lab_reaction.json` - runReaction intent
   - 3 labs (one with H, one with O, one empty)
   - Tests: Mineral consumption, OH production, cooldownTime

6. `power_spawn_process.json` - processPower intent
   - Power spawn with power + energy
   - Tests: Power consumed, energy consumed, ops generated (future - for user power tracking)

**Construction site structure:**
```json
{
  "_id": "site1",
  "type": "constructionSite",
  "x": 27,
  "y": 25,
  "structureType": "spawn",
  "user": "user1",
  "progress": 0,
  "progressTotal": 5000
}
```

**Lab structure (for reactions):**
```json
{
  "_id": "lab1",
  "type": "lab",
  "x": 25,
  "y": 25,
  "user": "user1",
  "store": {"H": 50, "energy": 10},
  "storeCapacityResource": {
    "H": 3000,
    "energy": 2000
  },
  "cooldownTime": 0,
  "hits": 500,
  "hitsMax": 500
}
```

---

### 1.5 Controller Fixtures (4 fixtures, ~2 hours)

**Fixtures:**
1. `controller_claim.json` - claimController intent (if implemented)
   - Neutral controller (level: 0, no user)
   - Creep with claim body part
   - Tests: Controller ownership change

2. `controller_reserve.json` - reserveController intent
   - Neutral controller
   - Creep with claim body part
   - Tests: Reservation increase

3. `controller_attack.json` - attackController intent
   - Enemy controller with progress
   - Creep with claim body part
   - Tests: Downgrade timer, progress reduction

4. `controller_safemode.json` - activateSafeMode intent (if implemented)
   - Controller with safeModeAvailable > 0
   - Tests: SafeMode timer, safeModeAvailable decrement

**Note:** Check if claimController, activateSafeMode, generateSafeMode, unclaim are implemented before creating fixtures.

---

### 1.6 Spawn Fixtures (3 fixtures, ~1.5 hours)

**Fixtures:**
1. `spawn_create.json` - spawnCreep intent
   - Spawn with energy (300)
   - Intent to spawn [WORK, CARRY, MOVE]
   - Tests: Energy consumption, creep creation (in spawning state)

2. `spawn_renew.json` - renewCreep intent
   - Spawn with energy
   - Creep with low TTL (200 ticks)
   - Tests: TTL increase, energy consumption

3. `spawn_recycle.json` - recycleCreep intent
   - Spawn
   - Creep to be recycled
   - Tests: Energy return (partial), creep removal

**Spawn structure:**
```json
{
  "_id": "spawn1",
  "type": "spawn",
  "x": 25,
  "y": 25,
  "user": "user1",
  "store": {"energy": 300},
  "storeCapacity": 300,
  "hits": 5000,
  "hitsMax": 5000,
  "spawning": null
}
```

---

### 1.7 Advanced Structures (2 fixtures, ~1 hour)

**Fixtures:**
1. `nuker_launch.json` - launchNuke intent
   - Nuker with energy + ghodium
   - Target room coordinates
   - Tests: Cooldown set, resources consumed, nuke object created

2. `factory_produce.json` - produce intent
   - Factory with components
   - Recipe for commodity (e.g., battery)
   - Tests: Component consumption, commodity production, cooldown

**Nuker structure:**
```json
{
  "_id": "nuker1",
  "type": "nuker",
  "x": 25,
  "y": 25,
  "user": "user1",
  "store": {
    "energy": 300000,
    "G": 5000
  },
  "storeCapacityResource": {
    "energy": 300000,
    "G": 5000
  },
  "cooldownTime": 0,
  "hits": 1000,
  "hitsMax": 1000
}
```

---

## Phase 2: Test Implementation (3-5 hours)

### 2.1 Create Test Methods

For each JSON fixture, add a corresponding test method in `EndToEndParityTests.cs`:

```csharp
[Fact]
public async Task Combat_Attack_MatchesNodeJsEngine()
{
    // Pattern established above
}

[Fact]
public async Task Build_Construction_MatchesNodeJsEngine()
{
    // ...
}

// Repeat for all 25-30 fixtures
```

**Effort:** ~10 minutes per test √ó 25 tests = 4 hours (includes running tests and debugging)

### 2.2 Verify Node.js Harness Support

Check `tools/parity-harness/engine/test-runner/processor-executor.js` intent mapping:

**Already supported (38 intent types):**
- ‚úÖ harvest, attack, heal, rangedAttack, rangedHeal
- ‚úÖ build, repair, dismantle
- ‚úÖ transfer, withdraw, pickup, drop
- ‚úÖ move, moveTo, pull
- ‚úÖ upgradeController, reserveController, attackController, claimController
- ‚úÖ transferEnergy (link)
- ‚úÖ runReaction, boostCreep, unboostCreep (lab)
- ‚úÖ processPower (power spawn)
- ‚úÖ produce (factory)
- ‚úÖ launchNuke (nuker)
- ‚úÖ spawnCreep, renewCreep, recycleCreep (spawn)
- ‚úÖ send (terminal)
- ‚úÖ tower-attack, tower-heal, tower-repair
- ‚úÖ activateSafeMode, unclaim (controller)
- ‚úÖ say, suicide
- ‚úÖ generateSafeMode
- ‚úÖ destroyStructure
- ‚úÖ observeRoom

**Action:** Verify all intents are in the mapping. Add any missing ones (unlikely based on E7.md).

---

## Phase 3: Divergence Resolution (2-8 hours)

### 3.1 Expected Divergences

Based on the link cooldown bug we just fixed, expect divergences in:

**High Risk:**
- Lab cooldowns (cooldownTime vs cooldown pattern)
- Boost calculations (multipliers, body part counts)
- Damage/heal range falloff formulas
- Fatigue calculations
- Construction progress formulas

**Medium Risk:**
- Resource overflow handling
- Capacity limit enforcement
- Edge case validation (e.g., target full, insufficient resources)

**Low Risk:**
- Simple transfers
- Basic movement
- Harvest mechanics (already passing)

### 3.2 Debugging Workflow

When divergence detected:

1. **Identify field:** Divergence report shows exact field (e.g., `creep1.store.energy`)
2. **Compare values:** Node.js: 47, .NET: 50 (difference: +3)
3. **Locate processor:** Find which processor step handles this intent
4. **Add logging:** Add debug output to processor (if needed)
5. **Compare logic:** Read Node.js processor file (tools/parity-harness/engine/screeps-modules/engine/src/processor/intents/...)
6. **Fix .NET:** Update calculation to match Node.js behavior
7. **Re-run test:** Verify parity achieved
8. **Check related tests:** Ensure fix doesn't break other tests

**Example (from link cooldown fix):**
```
Divergence: link1.cooldown
Node.js: 10
.NET: 410 (gameTime + 10)

Root cause: .NET used absolute time, Node.js uses countdown ticker
Fix: Change cooldownLedger[link.Id] = gameTime + ticks to currentCooldown + ticks
```

### 3.3 Effort Estimate

- Zero divergences (perfect parity): 0 hours üéâ
- 1-5 minor divergences: 1-2 hours (formula tweaks)
- 6-15 divergences: 3-5 hours (multiple processors affected)
- 16+ divergences: 6-8 hours (systematic issues, constants wrong)

**Most likely:** 3-5 hours (based on link cooldown being the only divergence so far in 4 fixtures)

---

## Phase 4: CI/CD Automation (2-3 hours)

### 4.1 GitHub Actions Workflow

**File:** `.github/workflows/parity-tests.yml`

```yaml
name: Parity Tests

on:
  pull_request:
    paths:
      - 'src/ScreepsDotNet.Engine/**'
      - 'src/ScreepsDotNet.Driver/**'
      - 'src/ScreepsDotNet.Engine.Tests/Parity/**'
      - 'tools/parity-harness/**'
  schedule:
    - cron: '0 0 * * 0'  # Weekly on Sunday

jobs:
  parity:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '12.22.12'

      - name: Cache Screeps repos
        uses: actions/cache@v3
        with:
          path: tools/parity-harness/engine/screeps-modules
          key: screeps-repos-${{ hashFiles('tools/parity-harness/versions.json') }}
          restore-keys: |
            screeps-repos-

      - name: Cache npm dependencies
        uses: actions/cache@v3
        with:
          path: tools/parity-harness/engine/node_modules
          key: npm-${{ hashFiles('tools/parity-harness/engine/package-lock.json') }}
          restore-keys: |
            npm-

      - name: Clone Screeps repos (if not cached)
        run: |
          cd tools/parity-harness/engine/scripts
          chmod +x clone-repos.sh
          ./clone-repos.sh

      - name: Install npm dependencies
        run: |
          cd tools/parity-harness/engine
          npm install --ignore-scripts --legacy-peer-deps

      - name: Run parity tests
        run: |
          cd src
          dotnet test ScreepsDotNet.slnx --filter Category=Parity --logger "console;verbosity=normal"

      - name: Upload divergence reports (if failed)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: parity-divergence-reports
          path: /tmp/nodejs-*.log
```

**Effort:** 1 hour to create workflow, 30 minutes to test, 30 minutes to document

### 4.2 Version Pinning Strategy

**File:** `tools/parity-harness/versions.json` (already exists)

```json
{
  "pinningEnabled": false,
  "development": {
    "engine": "master",
    "driver": "master",
    "common": "master"
  },
  "release": {
    "engine": "abc123def",
    "driver": "def456ghi",
    "common": "ghi789jkl"
  }
}
```

**Strategy:**
- Development/PRs: Use `master` (always test against latest)
- Weekly job: Test latest, create issues for divergences
- Release builds: Pin to validated commits after divergences fixed
- Update pins manually after E7 completion

**Effort:** Already configured, no additional work

---

## Phase 5: Documentation (1-2 hours)

### 5.1 Operator Playbook Entry

**File:** `docs/troubleshooting/parity-failures.md`

```markdown
# Debugging Parity Test Failures

## Symptom
Parity test fails with divergence report showing field-level differences between .NET and Node.js outputs.

## Example Error
```
‚ùå Combat_Attack_MatchesNodeJsEngine - FAILED

Divergence Report:
- creep2.hits: .NET=70, Node.js=50 (difference: +20)
  Message: Attack damage lower in .NET than Node.js
```

## Diagnosis Steps

1. **Identify the intent type**
   - Look at fixture name: `combat_attack.json` ‚Üí attack intent
   - Locate processor: `src/ScreepsDotNet.Engine/Processors/Steps/CombatResolutionStep.cs`

2. **Compare processor logic**
   - Node.js: `tools/parity-harness/engine/screeps-modules/engine/src/processor/intents/creeps/attack.js`
   - .NET: `CombatResolutionStep.cs` (attack intent handler)
   - Compare line-by-line: damage calculation, boost multipliers, edge cases

3. **Check constants**
   - Verify `ScreepsGameConstants.AttackPower` matches Node.js constant
   - Check boost multipliers in `BoostConstants.cs`

4. **Add debug logging** (if needed)
   ```csharp
   Console.WriteLine($"DEBUG: Calculating damage for {creep.Id}");
   Console.WriteLine($"  Base damage: {baseDamage}");
   Console.WriteLine($"  Boost multiplier: {boostMultiplier}");
   Console.WriteLine($"  Final damage: {finalDamage}");
   ```

5. **Run Node.js harness manually** (for detailed output)
   ```bash
   cd tools/parity-harness/engine
   node test-runner/run-fixture.js "../../src/ScreepsDotNet.Engine.Tests/Parity/Fixtures/combat_attack.json" --mongo "mongodb://localhost:27017"
   ```

## Common Issues

### 1. Constants Mismatch
**Symptom:** Consistent offset in calculations (e.g., always +5 or -10)
**Fix:** Compare constants in `ScreepsGameConstants.cs` vs Node.js `C` object

### 2. Cooldown Pattern Confusion
**Symptom:** Cooldown values are gameTime + ticks instead of just ticks
**Fix:** Check if structure uses `cooldown` (countdown) or `cooldownTime` (absolute)
- Links, extractors: Use `cooldown` (countdown ticker)
- Labs, terminals: Use `cooldownTime` (absolute game time)

### 3. Floating Point Precision
**Symptom:** Damage/heal values differ by 1-2 (rounding)
**Fix:** Use `Math.Ceiling()` or `Math.Floor()` to match Node.js behavior
```csharp
var damage = (int)Math.Ceiling(baseDamage * multiplier);
```

### 4. Missing Edge Case Validation
**Symptom:** .NET allows invalid intent, Node.js rejects it
**Fix:** Add validation check (e.g., target full, insufficient energy, out of range)

## Resolution Workflow

1. Fix .NET implementation to match Node.js
2. Re-run parity test: `dotnet test --filter "FullyQualifiedName~Combat_Attack_MatchesNodeJsEngine"`
3. Verify fix: Test should pass with no divergences
4. Check related tests: `dotnet test --filter Category=Parity`
5. Commit fix with descriptive message

## Prevention

- Always compare against Node.js source when implementing new features
- Add parity tests BEFORE implementing new processors
- Run parity tests on every PR (CI enforces this)

## Escalation

If divergence cannot be resolved after 2 hours:
1. Document divergence in GitHub issue
2. Tag as `parity-divergence`
3. Include fixture, expected vs actual output, suspected cause
4. Assign to Engine team lead for review
```

**Effort:** 1 hour to write, 30 minutes to review

### 5.2 Update E7 Documentation

**File:** `docs/engine/e7.md`

Add section:
```markdown
## Phase 4: Extended Coverage ‚úÖ COMPLETE

**Status:** Complete - January 22, 2026
**Test Count:** 32 parity tests (4 ‚Üí 32)
**Coverage:** 95% of implemented Engine features

**Fixtures Added:**
- Combat: attack, rangedAttack, heal, rangedHeal, dismantle (5 tests)
- Resources: drop, pickup, withdraw, transfer (tower), lab boost/unboost (5 tests)
- Movement: basic, pull, say (3 tests)
- Structures: build, repair, tower (attack/heal), lab reaction, power spawn (6 tests)
- Controller: claim, reserve, attack, safemode (4 tests)
- Spawn: create, renew, recycle (3 tests)
- Advanced: nuker, factory (2 tests)

**Divergences Resolved:** X divergences fixed (details in commits)
**Time Invested:** X hours (X for fixtures, X for tests, X for fixes)
```

**Effort:** 15 minutes

---

## Testing Strategy

### Unit Test Validation (Before Parity Tests)

Before creating parity fixtures, verify .NET processors work via existing unit tests:

```bash
# Check specific processor
dotnet test --filter "FullyQualifiedName~CombatResolutionStepTests"
dotnet test --filter "FullyQualifiedName~LabIntentStepTests"

# All Engine tests
dotnet test --filter "FullyQualifiedName~ScreepsDotNet.Engine.Tests"
```

**If unit tests fail:** Fix .NET implementation first, then create parity fixtures

### Parity Test Workflow

1. **Create fixture** (30 min)
2. **Add test method** (10 min)
3. **Run test** (1 min)
4. **If divergence:** Debug and fix (15 min - 2 hours)
5. **Verify fix** (1 min)
6. **Commit** (5 min)

**Per fixture:** 1-3 hours (depending on divergences)

---

## Critical Files to Modify

### New Files (25-30 files)
- `src/ScreepsDotNet.Engine.Tests/Parity/Fixtures/combat_attack.json`
- `src/ScreepsDotNet.Engine.Tests/Parity/Fixtures/combat_ranged.json`
- ... (25-30 total fixtures)

### Modified Files (2-5 files)
- `src/ScreepsDotNet.Engine.Tests/Parity/Tests/EndToEndParityTests.cs` - Add 25-30 test methods
- `docs/engine/e7.md` - Update Phase 4 status
- `.github/workflows/parity-tests.yml` - New CI workflow
- `docs/troubleshooting/parity-failures.md` - New troubleshooting guide
- Potentially 1-5 processor files if divergences found (e.g., `CombatResolutionStep.cs`, `LabIntentStep.cs`)

---

## Verification Plan

### After Each Phase

**Phase 1 Checkpoint:**
```bash
# Verify fixtures are valid JSON
for f in src/ScreepsDotNet.Engine.Tests/Parity/Fixtures/*.json; do
  jq empty "$f" && echo "‚úÖ $f" || echo "‚ùå $f"
done

# Run parity tests
dotnet test --filter Category=Parity

# Expected: All tests passing
```

**Phase 2 Checkpoint:**
```bash
# Count test methods (JSON fixture tests)
grep -c "MatchesNodeJsEngine" src/ScreepsDotNet.Engine.Tests/Parity/Tests/EndToEndParityTests.cs
# Expected: 28-32 (4 existing + 24-28 new)

# Count programmatic parity tests
grep -c "public async Task.*\[Trait(\"Category\", \"Parity\")]" src/ScreepsDotNet.Engine.Tests/Parity/Tests/*.cs
# Current: 17 (7 JSON + 10 keeper AI)

# Run all parity tests
dotnet test --filter Category=Parity --logger "console;verbosity=normal"
```

**Phase 4 Checkpoint:**
```bash
# Verify CI workflow
gh workflow run parity-tests.yml

# Check workflow status
gh run list --workflow=parity-tests.yml
```

### End-to-End Validation

**Success Criteria:**
1. ‚úÖ All parity tests passing (0 divergences)
2. ‚è≥ CI workflow running successfully (pending Phase 4)
3. ‚è≥ Coverage: 25-30 fixtures across all major intent types (17/30+ complete - 57%)
4. ‚è≥ Documentation complete (E7.md updated, playbook written)
5. ‚úÖ No regressions in existing tests (916/916 passing)

**Commands:**
```bash
# Full test suite
dotnet test src/ScreepsDotNet.slnx

# Parity tests only
dotnet test --filter Category=Parity

# Verify fixture count
ls -1 src/ScreepsDotNet.Engine.Tests/Parity/Fixtures/*.json | wc -l
# Current: 4, Expected final: 28-34 (4 existing + 24-30 new)

# Verify JSON fixture test count
grep -c "public async Task.*MatchesNodeJsEngine" src/ScreepsDotNet.Engine.Tests/Parity/Tests/EndToEndParityTests.cs
# Current: 7, Expected final: 28-34

# Verify total parity test count (JSON + programmatic)
dotnet test --filter Category=Parity --list-tests | grep -c "Test\ Name"
# Current: 17 (7 JSON + 10 keeper AI), Expected final: 40-45
```

---

## Risk Assessment

### High Confidence (Low Risk)
- ‚úÖ Harvest, transfer, controller upgrade, link transfer (already passing)
- ‚úÖ Infrastructure complete and tested
- ‚úÖ Node.js harness working perfectly

### Medium Confidence (Medium Risk)
- ‚ö†Ô∏è Combat calculations (range falloff formulas)
- ‚ö†Ô∏è Lab reactions (complex formulas, 62 recipes)
- ‚ö†Ô∏è Boost mechanics (40 boost types, body part interactions)
- ‚ö†Ô∏è Factory production (62 commodity recipes)

**Mitigation:** Expect 3-8 hours for divergence resolution in these areas

### Low Confidence (Higher Risk)
- ‚ö†Ô∏è Tower operations (range-based falloff, 3 intent types)
- ‚ö†Ô∏è Spawn mechanics (energy calculations, body part costs)
- ‚ö†Ô∏è Nuker launch (complex cooldown + targeting)

**Mitigation:** Create these fixtures last, allocate extra debugging time

### Blocked/Deferred
- ‚ùå Observer mechanics (`observeRoom` not implemented - E9 dependency)
- ‚ùå Terminal.send global (would require GlobalParityTestRunner - deferred)

---

## Success Metrics

**Current Progress (Phase 0 Complete):**
- Parity tests: 17/30+ complete (57%)
  - 7 JSON fixture tests (EndToEndParityTests)
  - 10 programmatic keeper AI tests (KeeperAiParityTests)
- Processors covered: 8/26 (31%)
- E1-E9 features: 40% coverage

**Target (When All Phases Complete):**
- Parity tests: 30+ total (aiming for 100% coverage of implemented features)
- Processors covered: 24/26 (92% - excluding observer + terminal.send)
- Intent types covered: 35/38 (92%)
- E1-E6 features: 95% coverage

**Quality:**
- Zero divergences (100% parity achieved)
- All tests passing (916 ‚Üí 940+ tests expected)
- CI/CD automated (weekly regression checks)

**Documentation:**
- E10 implementation complete
- Troubleshooting playbook written
- CI/CD documented

---

## Timeline Estimate

| Phase | Tasks | Effort |
|-------|-------|--------|
| Phase 1 | Create 25 JSON fixtures | 8-12 hours |
| Phase 2 | Add 25 test methods | 3-5 hours |
| Phase 3 | Debug/fix divergences | 2-8 hours |
| Phase 4 | CI/CD workflow | 2-3 hours |
| Phase 5 | Documentation | 1-2 hours |
| **Total** | | **16-30 hours** |

**Realistic estimate:** 20-25 hours (assuming 3-5 divergences found and fixed)

**Best case:** 16-18 hours (zero divergences, smooth execution)
**Worst case:** 28-32 hours (15+ divergences, systematic issues)

---

## Notes

- **Hybrid approach adopted:** JSON fixtures for player intents, programmatic tests for AI/passive systems
  - ‚úÖ Keeper AI: 10 programmatic tests (Phase 0 complete)
  - ‚è≥ Player intents: 25-30 JSON fixtures (Phase 1-3 pending)
- Start with combat and resource fixtures (highest value, lowest risk)
- Save tower/spawn/nuker for later (higher complexity)
- Run parity tests after every 3-5 fixtures (catch divergences early)
- Don't batch all fixtures then test - incremental validation is faster
- Document divergences as you find them (GitHub issues or E10.md)
- **Current progress:** 17/30+ parity tests (57%), 916 total tests passing
