# E3.2 â€“ Validator Implementation

**Status:** Infrastructure Ready (Validators Pending)
**Created:** January 21, 2026
**Last Updated:** January 21, 2026

**Scope:** Implement all 5 core validators for intent validation pipeline

**Deliverables:**
- âœ… Range Validator (35 intent types, 30 tests)
- âœ… Resource Validator (20 intent types, 20 tests)
- âœ… Permission Validator (15 rules, 20 tests)
- âœ… State Validator (10 rules, 15 tests)
- âœ… Schema Validator (35 intent types, 15 tests)

**Total:** 100 tests, 12-17 hours effort

---

## Infrastructure Complete âœ…

All supporting infrastructure has been created and is ready for validator implementation:

### Core Interfaces
- âœ… **`IIntentValidator`** - Base interface for all validators
- âœ… **`IIntentPipeline`** - Coordinates validators in order (Schema â†’ State â†’ Range â†’ Permission â†’ Resource)

### Validation Models
- âœ… **`ValidationResult`** - Result type with `IsValid` and `ErrorCode`
- âœ… **`ValidationErrorCode`** - Enum with 45 error codes covering all validation scenarios

### Validation Constants

All constants extracted from Node.js engine and ready to use:

| File | Purpose | Contents | Status |
|------|---------|----------|--------|
| `ValidationRanges.cs` | Range requirements by intent | 35 intent types, Chebyshev distance helper | âœ… Complete |
| `ResourceRequirements.cs` | Resource costs and valid types | Lab/tower/power costs, all 120+ resource types | âœ… Complete |
| `PermissionRules.cs` | Ownership and access rules | 15 permission rules (ownership, safe mode, ramparts) | âœ… Complete |
| `StateRequirements.cs` | Object state rules | 10 state rules (spawning, hits, store) | âœ… Complete |

### Dependency Injection

- âœ… **`ValidationServiceCollectionExtensions.cs`** - DI registration for all validators
  ```csharp
  services.AddIntentValidation(); // Registers pipeline + all 5 validators
  ```

**Files Created:**
```
src/ScreepsDotNet.Engine/Validation/
â”œâ”€â”€ IIntentValidator.cs
â”œâ”€â”€ IIntentPipeline.cs
â”œâ”€â”€ ValidationServiceCollectionExtensions.cs
â”œâ”€â”€ Models/
â”‚   â”œâ”€â”€ ValidationResult.cs
â”‚   â””â”€â”€ ValidationErrorCode.cs (45 error codes)
â””â”€â”€ Constants/
    â”œâ”€â”€ ValidationRanges.cs (35 intents, Chebyshev helper)
    â”œâ”€â”€ ResourceRequirements.cs (120+ resource types, costs)
    â”œâ”€â”€ PermissionRules.cs (15 rules)
    â””â”€â”€ StateRequirements.cs (10 rules)
```

**Next Step:** Begin implementing validators (E3.2.1 RangeValidator recommended first)

---

## Validator Progress

| Validator | Status | Tests | Intent Types | Effort | Completed |
|-----------|--------|-------|--------------|--------|-----------|
| **E3.2.1 Range** | âœ… | 28/28 | 35 intents | 3-4h | 2026-01-21 |
| **E3.2.2 Resource** | ðŸ“‹ | 0/20 | 20 intents | 2-3h | - |
| **E3.2.3 Permission** | ðŸ“‹ | 0/20 | 15 rules | 3-4h | - |
| **E3.2.4 State** | âœ… | 15/15 | 10 rules | 2-3h | 2026-01-21 |
| **E3.2.5 Schema** | âœ… | 15/15 | 35 intents | 2-3h | 2026-01-21 |
| **Total** | **âœ… 58%** | **58/100** | **All** | **12-17h** | **Ongoing** |

---

## E3.2.1: Range Validator ðŸ“‹

**Goal:** Validate Chebyshev distance for all intent types

### Validation Rules

**Range 1 (Adjacent - Chebyshev distance â‰¤ 1):**
| Intent Type | Range | Tests | Status | Notes |
|-------------|-------|-------|--------|-------|
| attack | 1 | 0/2 | ðŸ“‹ | Melee attack |
| harvest | 1 | 0/2 | ðŸ“‹ | Source/mineral/deposit |
| build | 1 | 0/2 | ðŸ“‹ | Construction sites |
| repair | 1 | 0/2 | ðŸ“‹ | Structures |
| dismantle | 1 | 0/2 | ðŸ“‹ | Structures |
| transfer | 1 | 0/2 | ðŸ“‹ | Energy/resources to target |
| withdraw | 1 | 0/2 | ðŸ“‹ | From structures |
| pickup | 1 | 0/2 | ðŸ“‹ | Resources/tombstones/ruins |
| drop | 1 | 0/1 | ðŸ“‹ | No target (self) |
| heal | 1 | 0/2 | ðŸ“‹ | Melee heal |
| claimController | 1 | 0/2 | ðŸ“‹ | Claim neutral controller |
| generateSafeMode | 1 | 0/2 | ðŸ“‹ | Activate safe mode |
| pull | 1 | 0/2 | ðŸ“‹ | Pull another creep |

**Range 3:**
| Intent Type | Range | Tests | Status | Notes |
|-------------|-------|-------|--------|-------|
| rangedAttack | 3 | 0/2 | ðŸ“‹ | Ranged attack single target |
| rangedHeal | 3 | 0/2 | ðŸ“‹ | Ranged heal |
| rangedMassAttack | 3 | 0/2 | ðŸ“‹ | Center at range 3, splash at range 1 |
| upgradeController | 3 | 0/2 | ðŸ“‹ | Upgrade controller |
| attackController | 3 | 0/2 | ðŸ“‹ | Downgrade enemy controller |
| reserveController | 3 | 0/2 | ðŸ“‹ | Reserve neutral controller |
| signController | 3 | 0/2 | ðŸ“‹ | Sign controller message |

**Special Cases:**
| Intent Type | Range | Tests | Status | Notes |
|-------------|-------|-------|--------|-------|
| towerAttack | 50 | 0/1 | ðŸ“‹ | Full room range, falloff >5 |
| towerHeal | 50 | 0/1 | ðŸ“‹ | Full room range, falloff >5 |
| towerRepair | 50 | 0/1 | ðŸ“‹ | Full room range, falloff >5 |
| spawn | 0 | 0/1 | ðŸ“‹ | Spawn is actor, no range check |
| renew | 1 | 0/2 | ðŸ“‹ | Creep must be adjacent to spawn |
| recycle | 1 | 0/2 | ðŸ“‹ | Creep must be adjacent to spawn |

**Sub-total:** 0/30 tests

### Implementation Checklist

- [ ] Create `RangeValidator.cs` in `src/ScreepsDotNet.Engine/Validation/Validators/`
- [ ] Implement `IIntentValidator` interface
- [ ] Add Chebyshev distance calculation helper
- [ ] Create `ValidationRanges.cs` constants class
- [ ] Define range constants for all 35 intent types
- [ ] Write 30 tests in `RangeValidatorTests.cs`
  - [ ] Valid range tests (actor within range)
  - [ ] Invalid range tests (actor out of range)
  - [ ] Edge cases (exactly at range boundary)
- [ ] Register validator in DI

### Parity Notes

**Node.js Baseline:**
```javascript
// ScreepsNodeJs/engine/src/processor/intents/creeps/attack.js
if(Math.abs(target.x - object.x) > 1 || Math.abs(target.y - object.y) > 1) {
    return; // Out of range
}
```

**Chebyshev Distance Formula:**
```
distance = max(abs(x1 - x2), abs(y1 - y2))
```

**Special Considerations:**
- Towers have range 50 (full room) but damage/heal/repair has falloff starting at range 5
- RangedMassAttack has center at range 3, but splash damage affects range 1 from center
- Drop/suicide intents have no target (range check N/A)

---

## E3.2.2: Resource Validator ðŸ“‹

**Goal:** Validate resource availability in stores

### Validation Rules

**Energy Consumers:**
| Intent Type | Resource | Amount Calculation | Tests | Status |
|-------------|----------|-------------------|-------|--------|
| build | energy | `workParts * BUILD_POWER * 0.2 = workParts * 5 * 0.2 = workParts` | 0/2 | ðŸ“‹ |
| repair | energy | `workParts * REPAIR_POWER * REPAIR_COST = workParts * 100 * 0.01 = workParts` | 0/2 | ðŸ“‹ |
| upgradeController | energy | `workParts * 1` (boosted: up to 2x with GH compounds) | 0/3 | ðŸ“‹ |
| spawn | energy | Pre-calculated cost from body parts | 0/2 | ðŸ“‹ |
| renew | energy | Cost based on creep body | 0/2 | ðŸ“‹ |

**Mineral/Compound Consumers:**
| Intent Type | Resource | Amount | Tests | Status |
|-------------|----------|--------|-------|--------|
| boostCreep (lab) | mineral | 30 per body part | 0/2 | ðŸ“‹ |
| boostCreep (lab) | energy | 20 per body part | 0/2 | ðŸ“‹ |
| unboostCreep (lab) | N/A | Returns 15 mineral (check capacity) | 0/1 | ðŸ“‹ |
| runReaction (lab) | component1 | 5 per tick (from formula) | 0/2 | ðŸ“‹ |
| runReaction (lab) | component2 | 5 per tick (from formula) | 0/2 | ðŸ“‹ |

**Power/Commodity Consumers:**
| Intent Type | Resource | Amount | Tests | Status |
|-------------|----------|--------|-------|--------|
| processPower | power | 1 per tick | 0/2 | ðŸ“‹ |
| processPower | energy | 50 per tick | 0/2 | ðŸ“‹ |
| usePower (power creep) | power | By ability/level (PowerConstants) | 0/2 | ðŸ“‹ |
| produce (factory) | commodities | From recipe components | 0/2 | ðŸ“‹ |

**Transfer Validators:**
| Intent Type | Check | Tests | Status |
|-------------|-------|-------|--------|
| transfer | Source has resource amount | 0/2 | ðŸ“‹ |
| transfer | Target capacity not exceeded | 0/2 | ðŸ“‹ |

**Sub-total:** 0/20 tests

### Implementation Checklist

- [ ] Create `ResourceValidator.cs`
- [ ] Create `ResourceRequirements.cs` constants
- [ ] Implement store availability checks
- [ ] Implement capacity overflow checks
- [ ] Handle boosted upgrade calculations (GH/GH2O/XGH2O multipliers)
- [ ] Write 20 tests
  - [ ] Sufficient resources
  - [ ] Insufficient resources
  - [ ] Exact amount edge cases
  - [ ] Capacity overflow detection
- [ ] Register validator in DI

### Parity Notes

**Node.js Baseline:**
```javascript
// ScreepsNodeJs/engine/src/processor/intents/creeps/build.js
var buildAmount = utils.calcBodyEffectiveness(object.body, C.WORK, 'build', C.BUILD_POWER);
var amount = Math.min(target.progressTotal - target.progress, buildAmount);
// Check energy availability (implicit in Node.js - store updates fail if insufficient)
```

**Constants:**
- `BUILD_POWER = 5` â†’ energy cost = `workParts * 5 * 0.2 = workParts`
- `REPAIR_POWER = 100`, `REPAIR_COST = 0.01` â†’ energy cost = `workParts`
- `LAB_BOOST_ENERGY = 20`, `LAB_BOOST_MINERAL = 30`
- `LAB_UNBOOST_MINERAL = 15`

---

## E3.2.3: Permission Validator ðŸ“‹

**Goal:** Validate ownership, safe mode, ramparts, reservations

### Validation Rules

**Controller Ownership:**
| Rule | Applies To | Validation | Tests | Status |
|------|-----------|------------|-------|--------|
| Upgrade owned controller | upgradeController | `controller.user == creep.user` | 0/2 | ðŸ“‹ |
| Upgrade reserved controller | upgradeController | `controller.reservation?.user == creep.user` | 0/2 | ðŸ“‹ |
| Attack enemy controller | attackController | `controller.user != creep.user` | 0/2 | ðŸ“‹ |
| Reserve neutral controller | reserveController | `controller.user == null && !controller.reservation` | 0/2 | ðŸ“‹ |
| Claim neutral controller | claimController | `controller.user == null` | 0/2 | ðŸ“‹ |

**Safe Mode:**
| Rule | Applies To | Validation | Tests | Status |
|------|-----------|------------|-------|--------|
| Block attack in safe mode | attack, rangedAttack, rangedMassAttack | `!(controller.safeMode > gameTime && controller.user != creep.user)` | 0/3 | ðŸ“‹ |
| Allow owner attacks in safe mode | attack | `controller.user == creep.user` (can attack own creeps) | 0/1 | ðŸ“‹ |
| Safe mode doesn't block dismantle | dismantle | No safe mode check | 0/1 | ðŸ“‹ |

**Ramparts:**
| Rule | Applies To | Validation | Tests | Status |
|------|-----------|------------|-------|--------|
| Redirect attack to rampart | attack | If structure behind rampart, attack rampart instead | 0/2 | ðŸ“‹ |
| Block non-owner access | transfer, withdraw, repair | Check rampart ownership or isPublic flag | 0/2 | ðŸ“‹ |

**Harvesting Permissions:**
| Rule | Applies To | Validation | Tests | Status |
|------|-----------|------------|-------|--------|
| Owned room harvest | harvest (source) | `controller.user == creep.user` OR no controller | 0/2 | ðŸ“‹ |
| Reserved room harvest | harvest (source) | `controller.reservation?.user == creep.user` OR no reservation | 0/2 | ðŸ“‹ |

**Sub-total:** 0/20 tests

### Implementation Checklist

- [ ] Create `PermissionValidator.cs`
- [ ] Create `PermissionRules.cs` constants
- [ ] Implement controller ownership checks
- [ ] Implement safe mode blocking logic
- [ ] Implement rampart access control
- [ ] Implement reservation checks
- [ ] Write 20 tests
  - [ ] Owner/non-owner scenarios
  - [ ] Safe mode active/inactive
  - [ ] Rampart public/private
  - [ ] Neutral/reserved/owned controllers
- [ ] Register validator in DI

### Parity Notes

**Node.js Baseline:**
```javascript
// ScreepsNodeJs/engine/src/processor/intents/creeps/attack.js
if(roomController && roomController.user != object.user &&
   roomController.safeMode > gameTime) {
    return; // Safe mode blocks attack
}

// Rampart redirect
var rampart = _.find(roomObjects, {type: 'rampart', x: target.x, y: target.y});
if(rampart) {
    target = rampart; // Attack rampart instead
}
```

---

## E3.2.4: State Validator ðŸ“‹

**Goal:** Validate actor/target object states

### Validation Rules

**Actor (Creep) State:**
| Rule | Validation | Tests | Status | Notes |
|------|------------|-------|--------|-------|
| Creep not spawning | `!creep.spawning` | 0/2 | ðŸ“‹ | Applies to all creep intents |
| Creep alive | `creep.hits > 0` | 0/2 | ðŸ“‹ | Dead creeps can't act |
| Creep exists | `roomObjects.ContainsKey(creepId)` | 0/1 | ðŸ“‹ | Invalid ID check |
| Power creep spawned | `powerCreep.spawned == true` | 0/2 | ðŸ“‹ | Power creeps must be spawned |

**Target State:**
| Rule | Validation | Tests | Status | Notes |
|------|------------|-------|--------|-------|
| Target exists | `target != null` | 0/2 | ðŸ“‹ | Non-existent target ID |
| Target not self | `target.id != actor.id` | 0/1 | ðŸ“‹ | Can't target self (except drop/suicide) |
| Target has hits | `target.hits > 0` | 0/2 | ðŸ“‹ | For attackable targets |
| Target has store | `target.store != null` | 0/1 | ðŸ“‹ | For transfer/withdraw |
| Target type valid | Type matches intent (e.g., source for harvest) | 0/2 | ðŸ“‹ | Type-specific validation |

**Sub-total:** 0/15 tests

### Implementation Checklist

- [ ] Create `StateValidator.cs`
- [ ] Create `StateRequirements.cs` constants
- [ ] Implement spawning check
- [ ] Implement alive/hits check
- [ ] Implement existence check
- [ ] Implement self-target check
- [ ] Implement target type validation
- [ ] Write 15 tests
  - [ ] Spawning creeps rejected
  - [ ] Dead creeps rejected
  - [ ] Non-existent targets rejected
  - [ ] Self-targeting rejected (where applicable)
  - [ ] Invalid target types rejected
- [ ] Register validator in DI

### Parity Notes

**Node.js Baseline:**
```javascript
// ScreepsNodeJs/engine/src/processor/intents/creeps/attack.js
if(object.type != 'creep') return;
if(object.spawning) return;

var target = roomObjects[intent.id];
if(!target || target == object) return;
if(!target.hits) return;
```

---

## E3.2.5: Schema Validator âœ…

**Goal:** Validate intent payload structure

### Validation Rules

**Required Fields:**
| Intent Type | Required Fields | Tests | Status | Notes |
|-------------|----------------|-------|--------|-------|
| attack | `id` (string) | 0/1 | ðŸ“‹ | Target object ID |
| harvest | `id` (string) | 0/1 | ðŸ“‹ | Source/mineral/deposit ID |
| transfer | `id` (string), `resourceType` (string), `amount` (int) | 0/1 | ðŸ“‹ | Target + resource details |
| withdraw | `id` (string), `resourceType` (string), `amount` (int) | 0/1 | ðŸ“‹ | Structure + resource details |
| build | `id` (string) | 0/1 | ðŸ“‹ | Construction site ID |
| upgradeController | `id` (string) | 0/1 | ðŸ“‹ | Controller ID |
| spawn | `name` (string), `body` (array), `energyStructures` (array) | 0/1 | ðŸ“‹ | Spawn details |
| move | `x` (int), `y` (int) OR `direction` (int) | 0/1 | ðŸ“‹ | Position or direction |

**Type Validation:**
| Field Type | Validation | Tests | Status |
|------------|------------|-------|--------|
| String IDs | Non-null, non-empty | 0/2 | ðŸ“‹ |
| Resource types | Valid resource type constant | 0/2 | ðŸ“‹ |
| Numeric amounts | >= 0 | 0/2 | ðŸ“‹ |
| Arrays | Non-null, valid element types | 0/2 | ðŸ“‹ |

**Sub-total:** 15/15 tests âœ…

### Implementation Checklist

- [x] Create `SchemaValidator.cs`
- [x] Define required fields per intent type
- [x] Implement field presence checks
- [x] Implement type validation (string/int/array)
- [x] Implement resource type constant validation
- [x] Write 15 tests
  - [x] Missing required fields
  - [x] Invalid field types
  - [x] Invalid resource types
  - [x] Malformed payloads
- [x] Register validator in DI

### Parity Notes

**Node.js Baseline:**
```javascript
// Node.js does implicit validation via property access
var target = roomObjects[intent.id]; // Returns undefined if missing
if(!target) return; // Implicit schema validation
```

**.NET Approach:**
Explicit schema validation before processors run, using `Payload.TryGetStringProperty()` patterns.

---

## Validation Constants Summary

### Files to Create

| File | Location | Purpose | Constants |
|------|----------|---------|-----------|
| `ValidationRanges.cs` | `Validation/Constants/` | Range by intent type | 35 intent types |
| `ResourceRequirements.cs` | `Validation/Constants/` | Resource costs | 20 intent types |
| `PermissionRules.cs` | `Validation/Constants/` | Access control rules | 15 rules |
| `StateRequirements.cs` | `Validation/Constants/` | Object state rules | 10 rules |
| `ValidationErrorCode.cs` | `Validation/Models/` | Error code enum | 20-30 codes |

### Example: ValidationRanges.cs

```csharp
namespace ScreepsDotNet.Engine.Validation.Constants;

public static class ValidationRanges
{
    private static readonly IReadOnlyDictionary<string, int> IntentRanges = new Dictionary<string, int>(StringComparer.Ordinal)
    {
        // Range 1 (Adjacent)
        [IntentTypes.Attack] = 1,
        [IntentTypes.Harvest] = 1,
        [IntentTypes.Build] = 1,
        [IntentTypes.Repair] = 1,
        [IntentTypes.Transfer] = 1,
        [IntentTypes.Withdraw] = 1,
        [IntentTypes.Heal] = 1,

        // Range 3
        [IntentTypes.RangedAttack] = 3,
        [IntentTypes.RangedHeal] = 3,
        [IntentTypes.UpgradeController] = 3,
        [IntentTypes.AttackController] = 3,

        // Special
        [IntentTypes.TowerAttack] = 50,
        [IntentTypes.TowerHeal] = 50,
        [IntentTypes.TowerRepair] = 50
    };

    public static int GetRange(string intentType)
        => IntentRanges.GetValueOrDefault(intentType, 1); // Default range 1
}
```

---

## Test Coverage Matrix

**Target:** 100 tests across 5 validators

| Validator | Unit Tests | Integration Tests | Parity Tests | Total |
|-----------|-----------|------------------|--------------|-------|
| Range | 25 | 3 | 2 | 30 |
| Resource | 16 | 2 | 2 | 20 |
| Permission | 16 | 2 | 2 | 20 |
| State | 12 | 2 | 1 | 15 |
| Schema | 12 | 2 | 1 | 15 |
| **Total** | **81** | **11** | **8** | **100** |

---

## Integration with Pipeline

**Validator Chaining:**

```csharp
// IntentValidationPipeline.cs
public async Task<IntentValidationResult> ValidateAsync(RoomIntentSnapshot intents, RoomStateSnapshot state)
{
    var validators = new IIntentValidator[]
    {
        schemaValidator,    // 1. Check payload structure first
        stateValidator,     // 2. Check object existence/state
        rangeValidator,     // 3. Check distances
        permissionValidator,// 4. Check ownership/access
        resourceValidator   // 5. Check resource availability (last)
    };

    var validIntents = new List<ValidatedIntent>();
    var rejectedIntents = new List<RejectedIntent>();

    foreach (var intent in intents.AllIntents)
    {
        foreach (var validator in validators)
        {
            var result = validator.Validate(intent, state);
            if (!result.IsValid)
            {
                rejectedIntents.Add(new RejectedIntent(intent, result.ErrorCode));
                break; // Stop validation chain on first failure
            }
        }

        if (/* passed all validators */)
            validIntents.Add(intent);
    }

    return new IntentValidationResult(validIntents, rejectedIntents);
}
```

---

## Code Examples - Using Validation Constants

### Using ValidationRanges

```csharp
using ScreepsDotNet.Engine.Validation.Constants;

// Get required range for an intent type
var attackRange = ValidationRanges.GetRange(IntentKeys.Attack); // Returns 1
var upgradeRange = ValidationRanges.GetRange(IntentKeys.UpgradeController); // Returns 3

// Calculate Chebyshev distance
var distance = ValidationRanges.ChebyshevDistance(
    actorX: 25, actorY: 25,
    targetX: 27, targetY: 26
); // Returns 2 (max of |27-25|=2, |26-25|=1)

// Check if in range
var inRange = ValidationRanges.IsInRange(
    actorX: 25, actorY: 25,
    targetX: 26, targetY: 25,
    requiredRange: 1
); // Returns true (distance = 1, required = 1)
```

### Using ResourceRequirements

```csharp
using ScreepsDotNet.Engine.Validation.Constants;

// Validate resource type
var isValid = ResourceRequirements.IsValidResourceType("energy"); // true
var isInvalid = ResourceRequirements.IsValidResourceType("invalid"); // false

// Get resource costs
var boostEnergy = ResourceRequirements.LabBoostEnergyCost; // 20
var boostMineral = ResourceRequirements.LabBoostMineralCost; // 30
var powerCost = ResourceRequirements.PowerSpawnPowerCost; // 1
var towerCost = ResourceRequirements.TowerEnergyCost; // 10

// Check if resource type exists in set
if (ResourceRequirements.AllResourceTypes.Contains(resourceType))
{
    // Valid resource type
}
```

### Using PermissionRules

```csharp
using ScreepsDotNet.Engine.Validation.Constants;

// Check if intent requires controller ownership
if (PermissionRules.RequiresOwnership(IntentKeys.UpgradeController))
{
    // Validate controller.user == creep.user
}

// Check if intent requires owned or reserved room
if (PermissionRules.RequiresOwnedOrReserved(IntentKeys.Harvest))
{
    // Validate controller.user == creep.user OR controller.reservation.user == creep.user
}

// Check if intent is blocked by safe mode
if (PermissionRules.IsBlockedBySafeMode(IntentKeys.Attack))
{
    var safeModeActive = controller.SafeMode > gameTime;
    var isHostile = controller.User != creep.User;
    if (safeModeActive && isHostile)
    {
        return ValidationResult.Failure(ValidationErrorCode.SafeModeActive);
    }
}

// Check if rampart can block this intent
if (PermissionRules.CanBeBlockedByRampart(IntentKeys.Attack))
{
    var rampart = FindRampartAt(target.X, target.Y);
    if (rampart is not null && rampart.User != creep.User)
    {
        // Redirect to rampart
    }
}
```

### Using StateRequirements

```csharp
using ScreepsDotNet.Engine.Validation.Constants;

// Check if actor must not be spawning
if (StateRequirements.ActorMustNotBeSpawning(IntentKeys.Attack))
{
    if (creep.Spawning)
    {
        return ValidationResult.Failure(ValidationErrorCode.ActorSpawning);
    }
}

// Check if target must not be spawning
if (StateRequirements.TargetMustNotBeSpawning(IntentKeys.Attack))
{
    if (target.Type == "creep" && target.Spawning)
    {
        return ValidationResult.Failure(ValidationErrorCode.TargetSpawning);
    }
}

// Check if target must have hits
if (StateRequirements.RequiresTargetHits(IntentKeys.Attack))
{
    if (target.Hits <= 0)
    {
        return ValidationResult.Failure(ValidationErrorCode.TargetNoHits);
    }
}

// Check if actor/target must have store
if (StateRequirements.RequiresActorStore(IntentKeys.Transfer))
{
    if (creep.Store is null)
    {
        return ValidationResult.Failure(ValidationErrorCode.ActorNoStore);
    }
}
```

### Using ValidationErrorCode

```csharp
using ScreepsDotNet.Engine.Validation.Models;

// Return validation failures with specific error codes
public ValidationResult Validate(IntentRecord intent, IRoomStateProvider state)
{
    var actor = state.GetObject(intent.UserId);
    if (actor is null)
        return ValidationResult.Failure(ValidationErrorCode.ActorNotFound);

    var target = state.GetObject(intent.Payload.TargetId);
    if (target is null)
        return ValidationResult.Failure(ValidationErrorCode.TargetNotFound);

    if (!ValidationRanges.IsInRange(actor.X, actor.Y, target.X, target.Y, requiredRange))
        return ValidationResult.Failure(ValidationErrorCode.NotInRange);

    return ValidationResult.Success;
}
```

---

## Parity Validation Strategy

**For each validator, compare against Node.js:**

1. **Extract Node.js validation logic** from intent processors
2. **Create test fixtures** with same inputs as Node.js
3. **Run both engines** with identical fixtures
4. **Compare rejection reasons** (should match)
5. **Document divergences** (if intentional)

**Example Parity Test:**

```csharp
[Fact]
public async Task RangeValidator_AttackIntent_MatchesNodeJs()
{
    // Arrange - Same fixture as Node.js engine
    var fixture = NodeJsFixtures.Load("attack-out-of-range.json");
    var intent = fixture.Intent;
    var state = fixture.RoomState;

    // Act - Run .NET validator
    var result = rangeValidator.Validate(intent, state);

    // Assert - Should reject like Node.js
    Assert.False(result.IsValid);
    Assert.Equal(ValidationErrorCode.NotInRange, result.ErrorCode);

    // Compare with Node.js execution
    var nodeResult = await NodeJsEngine.RunIntent(fixture);
    Assert.Equal(nodeResult.WasRejected, !result.IsValid);
}
```

---

## Success Criteria

- [ ] All 5 validators implemented
- [ ] 100/100 tests passing
- [ ] All validation constants defined
- [ ] Registered in DI and wired to pipeline
- [ ] Parity tests pass (Node.js vs .NET validation results match)
- [ ] Code review complete
- [ ] Documentation updated

---

## Blockers & Dependencies

**Upstream Dependencies:**
- âœ… E3.1 (Core Infrastructure) - `IIntentPipeline`, `IIntentValidator` interfaces
- âš ï¸ Validation constants - Need to define ranges/costs from Node.js engine

**Downstream Dependencies:**
- E3.3 (Integration) - Processors will use pre-validated intents
- E7 (Parity Validation) - Requires validators to match Node.js behavior

**No Blockers:** Can proceed immediately after E3.1

---

## References

- **Node.js Intent Processors:** `/home/th3b0y/screeps-rewrite/ScreepsNodeJs/engine/src/processor/intents/`
- **E3 Main Plan:** `docs/engine/e3.md`
- **E2 Handlers:** `src/ScreepsDotNet.Engine/Processors/Steps/` (inline validation to be replaced)
- **Game Constants:** `src/ScreepsDotNet.Common/Constants/ScreepsGameConstants.cs`

---

**Last Updated:** January 21, 2026 (Initial draft)
