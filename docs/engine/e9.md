# E9 â€“ NPC AI Logic

**Status:** ðŸ“‹ Not Started

**Purpose:** Implement AI behavior for NPC creeps (source keepers, invaders) to achieve full Node.js parity. NPCs spawn correctly (E5) but stand idle without AI.

---

## Scope

### In Scope
- âœ… Source Keeper AI (pathfinding, targeting, combat)
- âœ… Invader AI (basic movement and combat patterns)
- âœ… Memory field support (`memory_sourceId`, `memory_move`)
- âœ… Path caching and reuse logic
- âœ… Intent generation from AI step
- âœ… Legacy parity validation

### Out of Scope
- âŒ Advanced invader strategies (complex room claiming, coordinated attacks)
- âŒ Power bank mechanics (already complete - destruction via damage)
- âŒ NPC spawning logic (already complete in E5 Phase 3)

---

## Dependencies

### Must Be Complete First
- âœ… E5 Phase 3: Keeper lair spawning (keepers spawn but don't move)
- âœ… E6: Engine loop orchestration (AI needs to run in processor loop)
- ðŸ“‹ E7: Parity validation framework (for testing AI behavior)
- âœ… E8: Observability (for debugging AI decisions)

### Infrastructure Already Available
- âœ… Pathfinder: `IPathfinderService` with native C++ solver (D6)
- âœ… Intent handlers: move, attack, rangedAttack, rangedMassAttack (E2)
- âœ… Room state access: Query objects, filter by type/range (E2)
- âœ… Distance utilities: Room position calculations (E2)

---

## Problem Statement

**Current behavior:**
- Keeper lairs spawn source keeper creeps correctly (E5 Phase 3)
- Keepers stand idle at spawn position, never move or attack
- Players can freely harvest keeper rooms without resistance

**Expected behavior (Node.js parity):**
- Keepers patrol near assigned sources/minerals
- Keepers attack hostile creeps in range (melee + ranged)
- Keepers use pathfinding to navigate around obstacles
- Keepers cache movement paths for performance

---

## Implementation Plan

### Phase 1: Keeper AI (4-5 hours)

**Node.js Reference:** `/ScreepsNodeJs/engine/src/processor/intents/creeps/keepers/pretick.js` (72 lines)

#### Step 1: Add Memory Fields (30 minutes)

**Add to `RoomObjectSnapshot`:**
```csharp
public sealed record RoomObjectSnapshot(
    // ... existing fields ...
    string? MemorySourceId = null,          // NEW: Keeper's assigned source/mineral ID
    KeeperMoveMemory? MemoryMove = null     // NEW: Path caching for movement
);

public sealed record KeeperMoveMemory(
    string? Dest,           // Packed destination position
    string? Path,           // Serialized path (packed positions)
    int? Time,              // Game time when path was created
    int? LastMove           // Last time keeper moved (for collision detection)
);
```

**Add to `RoomObjectPatchPayload`:**
```csharp
public sealed record RoomObjectPatchPayload
{
    // ... existing fields ...
    public string? MemorySourceId { get; init; }
    public KeeperMoveMemory? MemoryMove { get; init; }
}
```

**Wire into storage layer:**
- Update MongoDB mapping for new fields
- Add bulk writer support for memory patches

#### Step 2: Implement KeeperAiStep (2 hours)

**File:** `src/ScreepsDotNet.Engine/Processors/Steps/KeeperAiStep.cs`

**Logic (from Node.js):**
```csharp
internal sealed class KeeperAiStep : IRoomProcessorStep
{
    public Task ExecuteAsync(RoomProcessorContext context, CancellationToken token)
    {
        // 1. Find all keeper creeps (user ID "3")
        var keepers = context.State.Objects.Values
            .Where(o => o.Type == RoomObjectTypes.Creep && o.UserId == NpcUserIds.SourceKeeper);

        foreach (var keeper in keepers)
        {
            var intents = GenerateKeeperIntents(keeper, context);
            // Inject intents into context for validation/execution
            InjectIntents(context, keeper.Id, intents);
        }

        return Task.CompletedTask;
    }

    private static Dictionary<string, object> GenerateKeeperIntents(
        RoomObjectSnapshot keeper,
        RoomProcessorContext context)
    {
        var intents = new Dictionary<string, object>();

        // A. Find target source/mineral
        var source = FindOrAssignSource(keeper, context);

        // B. Find hostile creeps
        var hostilesInMeleeRange = FindHostiles(keeper, context, range: 1);
        var hostilesInRangedRange = FindHostiles(keeper, context, range: 3);

        // C. Move toward source if not in range
        if (source is not null && Distance(keeper, source) > 1)
        {
            var direction = MoveTowards(keeper, source, context);
            if (direction > 0)
            {
                intents["move"] = new { direction };
            }
        }

        // D. Attack hostile in melee range (lowest HP)
        var meleeTarget = hostilesInMeleeRange.MinBy(h => h.Hits);
        if (meleeTarget is not null)
        {
            intents["attack"] = new { id = meleeTarget.Id, x = meleeTarget.X, y = meleeTarget.Y };
        }

        // E. Ranged attack logic
        if (hostilesInRangedRange.Any())
        {
            var damageByRange = new[] { 10, 10, 4, 1 };
            var massDamage = hostilesInRangedRange.Sum(h => damageByRange[Distance(keeper, h)]);

            if (massDamage > 13)
            {
                intents["rangedMassAttack"] = new { };
            }
            else
            {
                var rangedTarget = hostilesInRangedRange.MinBy(h => h.Hits);
                intents["rangedAttack"] = new { id = rangedTarget.Id };
            }
        }

        return intents;
    }

    private static RoomObjectSnapshot? FindOrAssignSource(
        RoomObjectSnapshot keeper,
        RoomProcessorContext context)
    {
        // Check if keeper has assigned source in memory
        if (keeper.MemorySourceId is not null)
        {
            if (context.State.Objects.TryGetValue(keeper.MemorySourceId, out var source))
            {
                return source;
            }
        }

        // Find nearest source/mineral within 5 tiles
        var nearbyResources = context.State.Objects.Values
            .Where(o => (o.Type == RoomObjectTypes.Source || o.Type == RoomObjectTypes.Mineral) &&
                        Distance(keeper, o) <= 5)
            .ToList();

        var closest = nearbyResources.FirstOrDefault();
        if (closest is not null)
        {
            // Store source ID in keeper memory
            context.MutationWriter.Patch(keeper.Id, new RoomObjectPatchPayload
            {
                MemorySourceId = closest.Id
            });
        }

        return closest;
    }

    private static int MoveTowards(
        RoomObjectSnapshot keeper,
        RoomObjectSnapshot target,
        RoomProcessorContext context)
    {
        const int pathReuseTime = 50; // ticks

        // Check if cached path is still valid
        if (keeper.MemoryMove is not null &&
            keeper.MemoryMove.Dest == PackPosition(target.X, target.Y) &&
            keeper.MemoryMove.Time.HasValue &&
            context.State.GameTime <= keeper.MemoryMove.Time + pathReuseTime)
        {
            // Reuse cached path
            return NextDirectionFromPath(keeper, keeper.MemoryMove.Path);
        }

        // Calculate new path using pathfinder
        var path = CalculatePath(keeper, target, context);
        if (path is null || path.Length == 0)
        {
            return 0; // No path found
        }

        // Cache path in memory
        context.MutationWriter.Patch(keeper.Id, new RoomObjectPatchPayload
        {
            MemoryMove = new KeeperMoveMemory(
                Dest: PackPosition(target.X, target.Y),
                Path: SerializePath(path),
                Time: context.State.GameTime,
                LastMove: null
            )
        });

        return GetDirectionToPosition(keeper, path[0]);
    }
}
```

**Key challenges:**
- Path serialization format (pack positions into strings for memory storage)
- Intent injection mechanism (add to existing intent pipeline or separate?)
- Pathfinder integration (call `IPathfinderService` from processor step)

#### Step 3: Path Caching Utilities (1 hour)

**Helper methods:**
- `PackPosition(x, y)` - Encode position as compact string (match Node.js format)
- `UnpackPosition(packed)` - Decode position from string
- `SerializePath(positions)` - Convert path array to packed string
- `DeserializePath(packed)` - Unpack path string to position array
- `NextDirectionFromPath(creep, path)` - Get next move direction from cached path

**Format (from Node.js):**
```javascript
// Position packing: 6 bits for X, 6 bits for Y â†’ single char
const packLocal = function(x, y) {
    let uint32 = 0;
    uint32 <<= 6; uint32 |= x;
    uint32 <<= 6; uint32 |= y;
    return String.fromCharCode(32+uint32);
};

// Path: concatenated packed positions
path = "abc..." // Each char is a packed position
```

#### Step 4: Testing (1.5 hours)

**Unit tests (10 tests):**
1. `FindOrAssignSource_NoMemory_FindsNearestWithin5Tiles`
2. `FindOrAssignSource_HasMemory_ReusesStoredSource`
3. `FindOrAssignSource_MemoryInvalid_FindsNewSource`
4. `MoveTowards_NoCachedPath_CalculatesNewPath`
5. `MoveTowards_HasValidCachedPath_ReusesPath`
6. `MoveTowards_CachedPathExpired_RecalculatesPath`
7. `AttackLogic_MeleeTarget_AttacksLowestHp`
8. `AttackLogic_RangedMassDamageHigh_UsesMassAttack`
9. `AttackLogic_RangedMassDamageLow_UsesSingleTarget`
10. `GenerateKeeperIntents_MultipleActions_CombinesMoveAndAttack`

**Integration test (1 test):**
- Keeper spawns, finds source, moves toward it, attacks intruder

**Parity test (1 test):**
- Compare keeper behavior with Node.js fixture (same room state â†’ same intents)

---

### Phase 2: Invader AI (2-3 hours) - OPTIONAL

**Node.js Reference:** `/ScreepsNodeJs/engine/src/processor/intents/creeps/invaders/pretick.js`

**Scope:**
- Basic invader movement patterns (patrol, attack)
- Similar to keeper AI but different target selection
- May defer if not critical for E7 parity

**Status:** TBD based on E7 parity requirements

---

## Success Criteria

### Phase 1 (Keeper AI)
1. âœ… Memory fields added to `RoomObjectSnapshot` and `RoomObjectPatchPayload`
2. âœ… `KeeperAiStep` implemented and registered in processor pipeline
3. âœ… Path caching/reuse logic functional
4. âœ… 10+ unit tests passing (target selection, movement, attack logic)
5. âœ… Integration test: keeper spawns â†’ moves â†’ attacks
6. âœ… Parity test: keeper behavior matches Node.js fixtures
7. âœ… Keepers defend keeper rooms against player intrusion

### Phase 2 (Invader AI) - If Implemented
1. âœ… `InvaderAiStep` implemented
2. âœ… Invader movement and attack patterns functional
3. âœ… Tests passing (similar to keeper tests)

---

## Effort Estimate

**Phase 1 (Keeper AI):** 5 hours
- Memory fields: 30 min
- KeeperAiStep implementation: 2 hours
- Path caching utilities: 1 hour
- Testing & parity: 1.5 hours

**Phase 2 (Invader AI):** 2-3 hours (if needed)

**Total:** 5-8 hours depending on invader AI scope

---

## Risks & Mitigations

### Risk 1: Pathfinder Integration Complexity
**Mitigation:** `IPathfinderService` already exists, just need to call it from AI step

### Risk 2: Memory Storage Format
**Mitigation:** Use Node.js packed format for exact parity (6-bit encoding per coordinate)

### Risk 3: Intent Injection Timing
**Mitigation:** AI runs in pretick phase before intent validation (existing E3 pipeline)

### Risk 4: Performance (AI for many keepers)
**Mitigation:** Path caching reduces pathfinder calls to 1 per 50 ticks per keeper

---

## Legacy Parity Notes

**Node.js behavior to match:**
1. **Target selection:** Find source/mineral within 5 tiles, store in `memory_sourceId`
2. **Path reuse:** Cache path for 50 ticks (configurable via `reusePath` option)
3. **Attack priority:** Melee target = lowest HP, ranged = mass attack if total damage > 13
4. **Movement:** Use pathfinder with `range: 1` to source, avoid obstacles
5. **Memory format:** Packed positions (6 bits X, 6 bits Y â†’ char code 32+value)

**Exact Node.js constants:**
```javascript
// Attack range thresholds
meleeRange = 1
rangedRange = 3

// Ranged attack damage by distance
damageByRange = [10, 10, 4, 1]  // [range 0, range 1, range 2, range 3]

// Mass attack threshold
massAttackThreshold = 13  // Use mass attack if total damage > 13

// Path reuse time
defaultPathReuseTime = 50  // ticks
```

**Deviations (acceptable):**
- None planned - aiming for 100% parity

---

## Testing Strategy

### Unit Tests (10+ tests)
- Target finding and assignment
- Path caching and reuse logic
- Attack target selection (melee/ranged/mass)
- Intent generation correctness

### Integration Tests (1 test)
- End-to-end keeper behavior in simulated room
- Spawn â†’ find source â†’ move â†’ attack intruder

### Parity Tests (1 test)
- Compare keeper intents with Node.js engine output
- Same room state â†’ same intent decisions

### Performance Tests
- Measure AI overhead per keeper (target: <1ms per keeper)
- Test path caching effectiveness (expect 50x reduction in pathfinder calls)

---

## Implementation Notes

### Intent Injection Mechanism

**Option A: Separate AI Intent Pipeline**
- AI generates intents before user intents are processed
- AI intents bypass user validation (NPCs are trusted)
- Pros: Clean separation, no validation overhead for NPCs
- Cons: Need separate intent injection path

**Option B: Inject into Existing Intent Pipeline**
- Add AI intents to room intent snapshot
- Run through existing E3 validation pipeline
- Pros: Reuses existing infrastructure
- Cons: Validation overhead for NPC intents (unnecessary)

**Recommendation:** Option A (separate AI intent pipeline)

### Memory Storage

**Node.js format:**
```javascript
keeper.memory_sourceId = "abc123"
keeper.memory_move = {
    dest: "a",           // Packed position (1 char)
    path: "abcdefg",     // Packed path (N chars)
    time: 12345,         // Game time
    lastMove: 12344      // Last move time
}
```

**C# equivalent:**
```csharp
public sealed record KeeperMoveMemory(
    string? Dest,
    string? Path,
    int? Time,
    int? LastMove
);
```

Store as JSON in MongoDB or use same packed format as Node.js.

---

## Open Questions

1. **Should invader AI be in E9 or deferred?**
   - Answer: Depends on E7 parity requirements - decide during E7

2. **Memory storage format: packed strings or JSON?**
   - Recommendation: Use packed strings for exact Node.js parity

3. **Where does AI step run in processor order?**
   - Recommendation: Pretick phase, before intent validation (E3)

4. **Do we need separate NullKeeperAiStep for testing?**
   - Answer: Yes, for tests that don't care about AI behavior

---

## Cross-References

**Roadmap:** `docs/engine/roadmap.md` â†’ E9 entry
**E5 Plan:** `docs/engine/e5.md` â†’ Phase 3 (keeper spawning)
**E7 Requirements:** `docs/engine/roadmap.md` â†’ E7 section (detailed plan pending)
**Pathfinder Docs:** `docs/driver/d6-pathfinder.md`
**Node.js Source:** `/ScreepsNodeJs/engine/src/processor/intents/creeps/keepers/pretick.js`

---

**Last Updated:** 2026-01-21
