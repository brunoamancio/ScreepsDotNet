# E7 â€“ Engine Parity Testing Infrastructure

**Status:** ðŸš§ In Progress (Phase 1 complete âœ…)
**Created:** 2026-01-22
**Last Updated:** 2026-01-22

**Purpose:** Build lockstep testing infrastructure to validate 100% behavioral parity between .NET Engine and Node.js engine. This infrastructure tests **ALL implemented engine features** (E1-E6 complete, E8-E9 as implemented), ensuring identical simulation results for all game mechanics.

**Important:** E7 is the *milestone for building the testing infrastructure*, not a feature set. The parity tests validate all features from all engine milestones.

---

## Dependencies

### Must Be Complete First
- âœ… E2: All handler families implemented (240 tests, 11/11 families)
- âœ… E3: Intent validation pipeline complete
- âœ… E4: Simulation kernel complete (passive regeneration)
- âœ… E5: Global systems complete (GCL, power, keeper lairs, nukers)
- âœ… E6: Engine orchestration complete (IEngineHost integration)
- âœ… E8: Observability complete (telemetry, diagnostics)

### Features NOT Ready for Testing (Out of Scope)
- âŒ **E9: NPC AI Logic** (not implemented)
  - Keeper AI: pathfinding, targeting, combat behavior
  - Invader AI: basic movement and attack patterns
  - Memory field support (`memory_sourceId`, `memory_move`)
  - **Impact:** Keeper/invader behavior cannot be validated until E9 complete
- âš ï¸ **E2 Deferred (Non-Parity-Critical):**
  - Event log emissions (visualization only)
  - Level-up notifications (UX only)
  - Stats recording (analytics only)
  - **Impact:** These are non-gameplay features, not critical for parity validation
- âš ï¸ **E8.1 Enhancements (Future):**
  - Real telemetry aggregation (stub services in place)
  - Real room state provider (stub services in place)
  - Performance profiling hooks (not implemented)
  - **Impact:** E8 core observability is complete, stubs sufficient for parity testing

**Coverage:** E7 will validate ~95% of gameplay mechanics (all E1-E6 + E8 core). E9 AI will be added to parity suite when implemented.

### Infrastructure Required
- âœ… Official Screeps GitHub repositories:
  - Engine: https://github.com/screeps/engine
  - Driver: https://github.com/screeps/driver
  - Common: https://github.com/screeps/common
- âœ… MongoDB 7 for Node.js test harness
- âœ… xunit v3 test infrastructure
- âœ… Node.js 10.13.0+ for running official engine processor (as specified in screeps package.json)

---

## Problem Statement

**Current State:**
- .NET Engine has 428 passing unit/integration tests covering E1-E6 features
- Tests verify internal logic but not behavioral parity with Node.js
- No automated way to detect divergences from legacy engine behavior
- Cannot confidently claim "drop-in replacement" status

**Goal:**
- Build lockstep testing framework that executes identical fixtures in both engines
- Compare outputs field-by-field to detect divergences
- Test **ALL engine features** from E1-E6 (movement, harvest, combat, controller, global systems, etc.)
- Automate parity validation in CI/CD pipeline
- Provide regression protection for future changes (E8-E9)

**Key Challenge:** Node.js engine has no existing test harness. We need to build test infrastructure from scratch.

**Scope:** This milestone builds infrastructure. Fixtures will test all E1-E6 features comprehensively.

---

## Architecture

### Three-Layer Testing Approach

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 1: Fixture Definition (JSON)                          â”‚
â”‚  - Room state (objects, terrain, intents)                    â”‚
â”‚  - Game time, user state                                     â”‚
â”‚  - Expected outputs (optional, for regression)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â–¼                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 2A: Node.js Runner â”‚  â”‚ Layer 2B: .NET Runner    â”‚
â”‚ - Load fixture into Mongo â”‚  â”‚ - Load fixture into DTO  â”‚
â”‚ - Execute processor.js    â”‚  â”‚ - Execute RoomProcessor  â”‚
â”‚ - Capture mutations       â”‚  â”‚ - Capture mutations      â”‚
â”‚ - Serialize to JSON       â”‚  â”‚ - Serialize to JSON      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚                         â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 3: Comparison Engine                                  â”‚
â”‚  - Diff room object states (field-by-field)                  â”‚
â”‚  - Diff global mutations (GCL, power, market)                â”‚
â”‚  - Diff action logs                                          â”‚
â”‚  - Report divergences with context                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Design Principles:**
1. **Fixture-first:** Define test scenarios as JSON files consumable by both engines
2. **Parallel execution:** Node.js and .NET run independently, compare outputs afterward
3. **Comprehensive comparison:** Compare mutations, stats, action logs, and final state
4. **Actionable errors:** Report divergences with full context (fixture name, object IDs, field paths)

---

## Implementation Plan

### Phase 1: Node.js Test Harness (5-6 hours)

**Goal:** Create Node.js test runner that executes fixtures and serializes outputs for comparison.

**Note:** This harness will be created in `tools/parity-harness/` and will clone the official Screeps repositories from GitHub.

#### Step 1.1: Repository Setup (30 minutes)

**Directory Structure:**
```
ScreepsDotNet/                    # GitHub repo root
â”œâ”€â”€ .claude/
â”œâ”€â”€ docs/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ ScreepsDotNet.Engine.Tests/
â”‚   â”‚   â””â”€â”€ Parity/
â”‚   â”‚       â””â”€â”€ Fixtures/        # Test fixtures
â”‚   â””â”€â”€ ...
â”œâ”€â”€ tools/
â”‚   â””â”€â”€ parity-harness/          # Multi-layer parity testing
â”‚       â”œâ”€â”€ README.md            # Multi-layer overview
â”‚       â”œâ”€â”€ package.json         # npm scripts per layer
â”‚       â”œâ”€â”€ versions.json        # Version pinning per layer
â”‚       â”œâ”€â”€ screeps-modules/     # Cloned repos (gitignored)
â”‚       â”‚   â”œâ”€â”€ engine/
â”‚       â”‚   â”œâ”€â”€ driver/
â”‚       â”‚   â””â”€â”€ common/
â”‚       â”œâ”€â”€ engine/              # E7: Engine parity harness
â”‚       â”‚   â”œâ”€â”€ README.md
â”‚       â”‚   â”œâ”€â”€ scripts/         # clone-repos.sh
â”‚       â”‚   â”œâ”€â”€ test-runner/    # Node.js test harness
â”‚       â”‚   â”‚   â”œâ”€â”€ fixture-loader.js
â”‚       â”‚   â”‚   â”œâ”€â”€ processor-executor.js
â”‚       â”‚   â”‚   â”œâ”€â”€ output-serializer.js
â”‚       â”‚   â”‚   â””â”€â”€ run-fixture.js
â”‚       â”‚   â”œâ”€â”€ fixtures/        # Test fixtures (Phase 4)
â”‚       â”‚   â””â”€â”€ examples/        # Example fixtures
â”‚       â”œâ”€â”€ driver/              # Driver parity (future)
â”‚       â”œâ”€â”€ backend/             # Backend parity (future)
â”‚       â””â”€â”€ common/              # Common parity (future)
â”œâ”€â”€ CLAUDE.md
â””â”€â”€ README.md
```

**File:** `tools/parity-harness/engine/scripts/clone-repos.sh`

```bash
#!/bin/bash
set -e

echo "Cloning official Screeps repositories..."

MODULES_DIR="screeps-modules"
mkdir -p "$MODULES_DIR"

# Clone official repos (or update if they exist)
if [ ! -d "$MODULES_DIR/engine" ]; then
  git clone https://github.com/screeps/engine.git "$MODULES_DIR/engine"
else
  cd "$MODULES_DIR/engine" && git pull && cd ../..
fi

if [ ! -d "$MODULES_DIR/driver" ]; then
  git clone https://github.com/screeps/driver.git "$MODULES_DIR/driver"
else
  cd "$MODULES_DIR/driver" && git pull && cd ../..
fi

if [ ! -d "$MODULES_DIR/common" ]; then
  git clone https://github.com/screeps/common.git "$MODULES_DIR/common"
else
  cd "$MODULES_DIR/common" && git pull && cd ../..
fi

echo "Installing dependencies..."
cd "$MODULES_DIR/engine" && npm install && cd ../..
cd "$MODULES_DIR/driver" && npm install && cd ../..
cd "$MODULES_DIR/common" && npm install && cd ../..

echo "Official Screeps modules ready for parity testing."
```

#### Step 1.2: Fixture Loader (1.5 hours)

**File:** `tools/parity-harness/engine/test-runner/fixture-loader.js`

**Responsibilities:**
- Load JSON fixture from file
- Insert room objects into MongoDB test database
- Insert intents into MongoDB test database
- Set up test environment (game time, users, terrain)

**Fixture Format (JSON):**
```json
{
  "gameTime": 100,
  "room": "W1N1",
  "shard": "shard0",
  "terrain": "...", // RLE encoded or tile array
  "objects": [
    {
      "_id": "creep1",
      "type": "creep",
      "x": 10,
      "y": 10,
      "user": "user1",
      "body": [{"type": "work"}, {"type": "move"}],
      "store": {"energy": 50},
      "hits": 100,
      "hitsMax": 100
    },
    {
      "_id": "source1",
      "type": "source",
      "x": 11,
      "y": 10,
      "energy": 300
    }
  ],
  "intents": {
    "user1": {
      "creep1": [
        {"intent": "harvest", "id": "source1"}
      ]
    }
  },
  "users": {
    "user1": {
      "gcl": {"level": 1, "progress": 0, "progressTotal": 1000000},
      "power": 0,
      "cpu": 100
    }
  }
}
```

**Implementation:**
```javascript
const MongoClient = require('mongodb').MongoClient;

async function loadFixture(fixturePath) {
  const fixture = JSON.parse(fs.readFileSync(fixturePath));
  const client = await MongoClient.connect('mongodb://localhost:27017');
  const db = client.db('screeps-parity-test');

  // Clear collections
  await db.collection('rooms.objects').deleteMany({room: fixture.room});
  await db.collection('rooms').deleteMany({_id: fixture.room});
  await db.collection('users').deleteMany({});

  // Insert fixture data
  await db.collection('rooms.objects').insertMany(
    fixture.objects.map(o => ({...o, room: fixture.room}))
  );

  await db.collection('rooms').insertOne({
    _id: fixture.room,
    status: 'normal',
    active: true,
    gameTime: fixture.gameTime
  });

  for (const [userId, userData] of Object.entries(fixture.users)) {
    await db.collection('users').insertOne({
      _id: userId,
      ...userData
    });
  }

  // Store intents in format expected by processor
  await db.collection('rooms.intents').deleteMany({room: fixture.room});
  await db.collection('rooms.intents').insertOne({
    room: fixture.room,
    intents: fixture.intents
  });

  return {client, db, fixture};
}
```

#### Step 1.3: Processor Executor (2 hours)

**File:** `tools/parity-harness/engine/test-runner/processor-executor.js`

**Responsibilities:**
- Execute Node.js processor.js with fixture data
- Capture bulk mutations (updates, inserts, deletes)
- Capture stats changes
- Serialize output to JSON

**Key Challenge:** Node.js engine expects full driver infrastructure (bulk writers, stats, event log). We need to create lightweight mocks.

**Implementation:**
```javascript
const processor = require('../screeps-modules/engine/src/processor');

async function executeProcessor(db, fixture) {
  // Mock bulk writer to capture mutations
  const bulkMutations = {
    updates: [],
    inserts: [],
    deletes: []
  };

  const mockBulk = {
    update: (obj, changes) => {
      bulkMutations.updates.push({id: obj._id, changes});
    },
    insert: (obj) => {
      bulkMutations.inserts.push(obj);
    },
    remove: (id) => {
      bulkMutations.deletes.push(id);
    }
  };

  // Mock stats sink
  const stats = {};
  const mockStats = {
    inc: (key, userId, amount) => {
      stats[`${userId}.${key}`] = (stats[`${userId}.${key}`] || 0) + amount;
    }
  };

  // Mock event log
  const eventLog = [];

  // Build scope object expected by processor
  const scope = {
    roomObjects: await loadRoomObjects(db, fixture.room),
    roomTerrain: await loadRoomTerrain(db, fixture.room),
    roomController: null, // Load if exists
    gameTime: fixture.gameTime,
    bulk: mockBulk,
    stats: mockStats,
    eventLog: eventLog
  };

  // Execute all intents
  for (const [userId, userIntents] of Object.entries(fixture.intents)) {
    for (const [objectId, intents] of Object.entries(userIntents)) {
      const object = scope.roomObjects[objectId];
      for (const intent of intents) {
        const intentProcessor = require(`../screeps-modules/engine/src/processor/intents/${getIntentPath(intent.intent)}`);
        intentProcessor(object, intent, scope);
      }
    }
  }

  return {
    mutations: bulkMutations,
    stats: stats,
    eventLog: eventLog
  };
}

function getIntentPath(intentName) {
  // Map intent names to processor file paths
  const intentMap = {
    'harvest': 'creeps/harvest',
    'attack': 'creeps/attack',
    'move': 'movement',
    // ... all intent mappings
  };
  return intentMap[intentName];
}
```

#### Step 1.4: Output Serializer (1 hour)

**File:** `tools/parity-harness/engine/test-runner/output-serializer.js`

**Responsibilities:**
- Query final room state from MongoDB after mutations
- Serialize to JSON format matching .NET output
- Include mutations, stats, and action logs

**Output Format:**
```json
{
  "mutations": {
    "patches": [
      {"objectId": "creep1", "store": {"energy": 54}},
      {"objectId": "source1", "energy": 296}
    ],
    "upserts": [],
    "removals": []
  },
  "stats": {
    "user1.energyHarvested": 4
  },
  "actionLogs": {
    "creep1": {"harvest": {"x": 11, "y": 10}}
  },
  "finalState": {
    "creep1": {/* full object state */},
    "source1": {/* full object state */}
  }
}
```

#### Step 1.5: CLI Wrapper (30 minutes)

**File:** `tools/parity-harness/engine/test-runner/run-fixture.js`

**CLI Interface:**
```bash
node run-fixture.js path/to/fixture.json --output output.json
```

**Responsibilities:**
- Load fixture
- Execute processor
- Serialize output
- Write to file

---

### Phase 2: .NET Test Runner (4-5 hours)

**Goal:** Create .NET test runner that processes same fixtures and produces comparable output.

#### Step 2.1: Fixture Loader (1.5 hours)

**File:** `src/ScreepsDotNet.Engine.Tests/Parity/Fixtures/FixtureLoader.cs`

**Responsibilities:**
- Parse JSON fixture
- Convert to `RoomState` DTO
- Build `RoomProcessorContext`

**Implementation:**
```csharp
public sealed class FixtureLoader
{
    public static ParityFixture Load(string fixturePath)
    {
        var json = File.ReadAllText(fixturePath);
        var fixture = JsonSerializer.Deserialize<ParityFixtureJson>(json)!;

        return new ParityFixture(
            GameTime: fixture.GameTime,
            Room: fixture.Room,
            Shard: fixture.Shard,
            State: BuildRoomState(fixture),
            ExpectedOutput: fixture.ExpectedOutput
        );
    }

    private static RoomState BuildRoomState(ParityFixtureJson fixture)
    {
        var objects = fixture.Objects
            .Select(MapToRoomObjectSnapshot)
            .ToDictionary(o => o.Id, o => o, StringComparer.Ordinal);

        var intents = BuildIntentSnapshot(fixture.Intents);

        var users = fixture.Users
            .ToDictionary(
                kvp => kvp.Key,
                kvp => new UserState(kvp.Value.Gcl, kvp.Value.Power, kvp.Value.Cpu),
                StringComparer.Ordinal
            );

        return new RoomState(
            fixture.Room,
            fixture.GameTime,
            null, // controller loaded separately
            objects,
            users,
            intents,
            terrain: new Dictionary<string, RoomTerrainSnapshot>(),
            visualizations: []
        );
    }
}
```

#### Step 2.2: Test Runner (1.5 hours)

**File:** `src/ScreepsDotNet.Engine.Tests/Parity/ParityTestRunner.cs`

**Responsibilities:**
- Execute `RoomProcessor` with fixture state
- Capture mutations from `CapturingMutationWriter`
- Capture stats from `CapturingStatsSink`
- Serialize to JSON matching Node.js format

**Implementation:**
```csharp
public sealed class ParityTestRunner
{
    public async Task<ParityOutput> RunFixtureAsync(ParityFixture fixture)
    {
        var mutationWriter = new CapturingMutationWriter();
        var statsSink = new CapturingStatsSink();
        var globalWriter = new CapturingGlobalMutationWriter();

        var context = new RoomProcessorContext(
            fixture.State,
            mutationWriter,
            statsSink,
            globalWriter
        );

        var processor = new RoomProcessor(/* inject all steps */);
        await processor.ProcessRoomAsync(context, CancellationToken.None);

        return new ParityOutput(
            Mutations: new MutationCapture(
                Patches: mutationWriter.Patches,
                Upserts: mutationWriter.Upserts,
                Removals: mutationWriter.Removals
            ),
            Stats: statsSink.Captures,
            ActionLogs: ExtractActionLogs(mutationWriter.Patches),
            FinalState: BuildFinalState(fixture.State, mutationWriter)
        );
    }
}
```

#### Step 2.3: Output Serializer (1 hour)

**File:** `src/ScreepsDotNet.Engine.Tests/Parity/ParityOutputSerializer.cs`

**Responsibilities:**
- Serialize .NET output to JSON format matching Node.js
- Handle type conversions (enums, dictionaries, etc.)
- Ensure field names match exactly

#### Step 2.4: Parity Test Base Class (30 minutes)

**File:** `src/ScreepsDotNet.Engine.Tests/Parity/ParityTestBase.cs`

**Pattern:**
```csharp
public abstract class ParityTestBase
{
    protected async Task AssertParityAsync(string fixturePath)
    {
        // 1. Run Node.js fixture
        var nodeOutput = await RunNodeFixtureAsync(fixturePath);

        // 2. Run .NET fixture
        var dotnetOutput = await RunDotNetFixtureAsync(fixturePath);

        // 3. Compare outputs
        var diff = ParityComparator.Compare(nodeOutput, dotnetOutput);

        // 4. Assert no divergences
        Assert.Empty(diff.Divergences);
    }
}
```

---

### Phase 3: Comparison Engine (3-4 hours)

**Goal:** Build robust comparison engine that detects and reports divergences.

#### Step 3.1: Field-by-Field Diff (2 hours)

**File:** `src/ScreepsDotNet.Engine.Tests/Parity/ParityComparator.cs`

**Responsibilities:**
- Compare mutations (patches, upserts, removals)
- Compare stats (field-by-field)
- Compare action logs (nested structure)
- Compare final state (all object fields)

**Key Challenges:**
- Handle floating-point precision (energy, cooldowns)
- Handle ordering differences (unordered collections)
- Handle nullable vs undefined differences
- Handle computed fields (_actionLog)

**Implementation:**
```csharp
public sealed class ParityComparator
{
    public static ParityDiff Compare(ParityOutput node, ParityOutput dotnet)
    {
        var divergences = new List<Divergence>();

        // Compare mutations
        divergences.AddRange(CompareMutations(node.Mutations, dotnet.Mutations));

        // Compare stats
        divergences.AddRange(CompareStats(node.Stats, dotnet.Stats));

        // Compare action logs
        divergences.AddRange(CompareActionLogs(node.ActionLogs, dotnet.ActionLogs));

        // Compare final state
        divergences.AddRange(CompareFinalState(node.FinalState, dotnet.FinalState));

        return new ParityDiff(divergences);
    }

    private static IEnumerable<Divergence> CompareMutations(
        MutationCapture node,
        MutationCapture dotnet)
    {
        // Compare patches
        var nodePatches = node.Patches.ToDictionary(p => p.ObjectId);
        var dotnetPatches = dotnet.Patches.ToDictionary(p => p.ObjectId);

        foreach (var (objectId, nodePatch) in nodePatches)
        {
            if (!dotnetPatches.TryGetValue(objectId, out var dotnetPatch))
            {
                yield return new Divergence(
                    Path: $"mutations.patches[{objectId}]",
                    NodeValue: nodePatch,
                    DotNetValue: null,
                    Message: "Patch exists in Node.js but not in .NET"
                );
                continue;
            }

            // Compare fields within patch
            foreach (var field in GetPatchFields(nodePatch))
            {
                var nodeValue = GetFieldValue(nodePatch, field);
                var dotnetValue = GetFieldValue(dotnetPatch, field);

                if (!ValuesEqual(nodeValue, dotnetValue))
                {
                    yield return new Divergence(
                        Path: $"mutations.patches[{objectId}].{field}",
                        NodeValue: nodeValue,
                        DotNetValue: dotnetValue,
                        Message: $"Field '{field}' differs"
                    );
                }
            }
        }
    }
}
```

#### Step 3.2: Divergence Reporter (1 hour)

**File:** `src/ScreepsDotNet.Engine.Tests/Parity/DivergenceReporter.cs`

**Responsibilities:**
- Format divergences in human-readable format
- Group divergences by category (mutations, stats, state)
- Provide context (fixture name, object IDs)
- Generate actionable error messages

**Example Output:**
```
Parity Test Failed: harvest_basic.json

Divergences (3):

1. mutations.patches[creep1].store.energy
   Node.js: 54
   .NET:    53
   Message: Energy amount differs by 1

2. stats.user1.energyHarvested
   Node.js: 4
   .NET:    3
   Message: Harvested stat differs

3. finalState.source1.energy
   Node.js: 296
   .NET:    297
   Message: Source energy mismatch
```

---

### Phase 4: Parity Test Suite (6-8 hours)

**Goal:** Create comprehensive fixtures covering **all E1-E6 engine features**.

#### Step 4.1: Core Mechanics Fixtures (3 hours)

**Fixtures to Create (30-40 fixtures spanning E1-E6):**

**Movement (6 fixtures) - E1/E2:**
- Basic move (4 directions)
- Pull mechanics
- Fatigue calculations (E4 simulation kernel)
- Room edge transitions
- Portal transfers
- Crashes and swapping

**Harvest (4 fixtures) - E2:**
- Source harvesting
- Mineral extraction
- Deposit harvesting
- Overflow drops

**Build/Repair (4 fixtures) - E2:**
- Construction progress
- Structure repairs
- Blueprint decay (E4 simulation kernel)
- Energy consumption

**Combat (5 fixtures) - E2:**
- Attack (melee)
- Ranged attack
- Heal (self and others)
- Tower operations
- Rampart protection

**Controller (5 fixtures) - E2/E5:**
- Upgrade (normal, boosted) - E2
- Downgrade mechanics - E4
- Level transitions - E5 (GCL updates)
- Safe mode - E2
- Reservation - E2

**Resource I/O (3 fixtures) - E2:**
- Transfer (creep-structure, structure-structure)
- Withdraw
- Pickup/Drop

**Lab (3 fixtures) - E2:**
- Reactions (sample of 62 formulas)
- Boost/unboost
- Cooldowns (E4 simulation kernel)

**Power (3 fixtures) - E5:**
- Power spawn processing
- Power creep abilities (sample of 18 abilities)
- Effect decay (E4 simulation kernel)

**Structures (4 fixtures) - E2/E5:**
- Link transfers - E2
- Factory production - E2
- Nuker launch/landing - E5
- Keeper lair spawning - E5

#### Step 4.2: Edge Cases (2 hours)

**Fixtures to Create (15-20 fixtures testing E4 simulation kernel):**
- Empty stores
- Full stores (overflow)
- Zero-hit structures (decay complete)
- TTL expiration (E4)
- Fatigue edge cases (E4)
- Cooldown edge cases (E4)
- Multiple simultaneous actions
- Conflicting intents
- Safe mode interactions
- Boost exhaustion

#### Step 4.3: Validation Parity (1.5 hours)

**E3 Milestone Coverage:**
Create fixtures that test intent validation parity (rejected intents should match Node.js behavior).

**Fixtures (4-6 fixtures testing E3 validation):**
- Out of range actions (range checks)
- Insufficient resources (resource checks)
- Permission violations (ownership checks)
- Invalid targets (target validation)

#### Step 4.4: Test Organization (30 minutes)

**Structure:**
```
src/ScreepsDotNet.Engine.Tests/
â””â”€â”€ Parity/
    â”œâ”€â”€ Fixtures/
    â”‚   â”œâ”€â”€ Movement/
    â”‚   â”‚   â”œâ”€â”€ basic_move.json
    â”‚   â”‚   â”œâ”€â”€ pull_chain.json
    â”‚   â”‚   â””â”€â”€ portal_transfer.json
    â”‚   â”œâ”€â”€ Harvest/
    â”‚   â”‚   â”œâ”€â”€ source_harvest.json
    â”‚   â”‚   â”œâ”€â”€ mineral_extract.json
    â”‚   â”‚   â””â”€â”€ overflow_drop.json
    â”‚   â””â”€â”€ ... (organized by mechanic)
    â”œâ”€â”€ Tests/
    â”‚   â”œâ”€â”€ MovementParityTests.cs
    â”‚   â”œâ”€â”€ HarvestParityTests.cs
    â”‚   â””â”€â”€ ... (xunit test classes)
    â”œâ”€â”€ Infrastructure/
    â”‚   â”œâ”€â”€ ParityTestBase.cs
    â”‚   â”œâ”€â”€ FixtureLoader.cs
    â”‚   â”œâ”€â”€ ParityTestRunner.cs
    â”‚   â”œâ”€â”€ ParityComparator.cs
    â”‚   â””â”€â”€ DivergenceReporter.cs
    â””â”€â”€ NodeJsRunner/
        â””â”€â”€ NodeJsFixtureExecutor.cs (Process wrapper)
```

---

### Phase 5: Automation & CI (2-3 hours)

**Goal:** Automate parity testing in CI/CD pipeline.

#### Step 5.1: Fixture Runner Script (1 hour)

**File:** `tools/parity-harness/scripts/run-parity-tests.sh`

```bash
#!/bin/bash
set -e

echo "Starting Screeps Parity Tests..."

# Clone/update official Screeps repositories
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"
./clone-repos.sh

# Start MongoDB for tests
docker run -d --name screeps-parity-mongo -p 27017:27017 mongo:7

# Run Node.js fixtures
cd ../test-runner
for fixture in ../../../src/ScreepsDotNet.Engine.Tests/Parity/Fixtures/**/*.json; do
  echo "Running Node.js: $fixture"
  node run-fixture.js "$fixture" --output "${fixture%.json}.node.json"
done

# Run .NET parity tests
cd ../../..  # Back to repo root
dotnet test --filter "Category=Parity"

# Cleanup
docker stop screeps-parity-mongo
docker rm screeps-parity-mongo
```

#### Step 5.2: GitHub Actions Workflow (1 hour)

**File:** `.github/workflows/parity-tests.yml`

```yaml
name: E7 Parity Tests

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  schedule:
    # Run weekly to detect upstream changes in official Screeps repos
    - cron: '0 0 * * 0'

jobs:
  parity:
    runs-on: ubuntu-latest

    services:
      mongodb:
        image: mongo:7
        ports:
          - 27017:27017

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '10.13.0'  # Minimum version required by screeps package

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '9.0.x'

      - name: Clone Official Screeps Repositories
        working-directory: tools/parity-harness/scripts
        run: |
          chmod +x clone-repos.sh
          ./clone-repos.sh

      - name: Install Parity Harness Dependencies
        working-directory: tools/parity-harness/test-runner
        run: npm install

      - name: Run Parity Tests
        run: dotnet test --filter "Category=Parity" --logger "console;verbosity=detailed"

      - name: Upload Divergence Reports
        if: failure()
        uses: actions/upload-artifact@v3
        with:
          name: parity-divergences
          path: src/ScreepsDotNet.Engine.Tests/Parity/Reports/
```

#### Step 5.3: Version Pinning Strategy (1 hour)

**Challenge:** Official Screeps repositories may change over time, potentially breaking parity tests.

**Strategy:**

**Option A: Always Use Latest (Recommended for Development)**
- Clone `master`/`main` branch on every CI run
- Detect divergences early when upstream changes
- Requires active monitoring and quick fixes
- Weekly scheduled CI runs catch upstream changes

**Option B: Pin to Specific Commits/Tags**
- Lock to specific commit SHAs in `parity-harness/versions.json`:
  ```json
  {
    "engine": "abc123def456...",
    "driver": "789ghi012jkl...",
    "common": "345mno678pqr...",
    "lastUpdated": "2026-01-22"
  }
  ```
- Update pins manually after validating changes
- More stable but may miss important upstream fixes

**Recommended Hybrid Approach:**
1. **Development/PR builds:** Use latest (Option A)
2. **Release builds:** Pin to validated commits (Option B)
3. **Weekly scheduled job:** Test against latest and report divergences
4. **Version update process:**
   - Weekly job detects upstream changes
   - Create issue with divergence report
   - Fix divergences in .NET Engine
   - Update version pins after validation

**Implementation:**

**File:** `tools/parity-harness/versions.json`
```json
{
  "pinningEnabled": false,
  "pins": {
    "engine": "master",
    "driver": "master",
    "common": "master"
  },
  "lastValidated": "2026-01-22",
  "notes": "Using latest. Update pins after validating upstream changes."
}
```

**File:** `tools/parity-harness/engine/scripts/clone-repos.sh` (updated)
```bash
#!/bin/bash
set -e

VERSIONS_FILE="versions.json"
PINNING_ENABLED=$(jq -r '.pinningEnabled' "$VERSIONS_FILE")

if [ "$PINNING_ENABLED" = "true" ]; then
  ENGINE_REF=$(jq -r '.pins.engine' "$VERSIONS_FILE")
  DRIVER_REF=$(jq -r '.pins.driver' "$VERSIONS_FILE")
  COMMON_REF=$(jq -r '.pins.common' "$VERSIONS_FILE")
  echo "Using pinned versions: engine=$ENGINE_REF, driver=$DRIVER_REF, common=$COMMON_REF"
else
  ENGINE_REF="master"
  DRIVER_REF="master"
  COMMON_REF="master"
  echo "Using latest versions from master branches"
fi

# Clone and checkout specific refs
# ... (rest of implementation)
```

---

### Phase 6: Documentation (1-2 hours)

**Goal:** Document parity testing framework for contributors.

#### Step 6.1: Update This Document (30 minutes)

Mark phases as complete as they're implemented. Update test counts and success criteria.

#### Step 6.2: Update Roadmap (15 minutes)

**File:** `docs/engine/roadmap.md`

Mark E7 as complete, update test counts.

#### Step 6.3: Add Operator Playbook Entry (15 minutes)

**File:** `docs/engine/operator-playbooks.md`

Add debugging workflow for parity failures:
- How to reproduce parity failures locally
- How to debug divergences
- How to update baselines
- Common causes of divergences

---

## Effort Estimate

| Phase | Estimated Time | Description |
|-------|----------------|-------------|
| Phase 1 | 5-6 hours | Node.js test harness |
| Phase 2 | 4-5 hours | .NET test runner |
| Phase 3 | 3-4 hours | Comparison engine |
| Phase 4 | 6-8 hours | Parity test suite (40-60 fixtures) |
| Phase 5 | 2-3 hours | Automation & CI |
| Phase 6 | 1-2 hours | Documentation |
| **Total** | **21-28 hours** | **3-4 days of focused work** |

---

## Success Criteria

### Phase 1-3 (Infrastructure)
1. âœ… Node.js test harness can execute fixtures and serialize output
2. âœ… .NET test runner can process same fixtures
3. âœ… Comparison engine detects divergences
4. âœ… At least 1 passing parity test (basic harvest)

### Phase 4 (Coverage)
1. âœ… 40+ parity fixtures covering E1-E6 features (~95% of gameplay)
2. âœ… All E2 handler families have parity tests (11 families)
3. âœ… E3 validator parity tests created (validation rules)
4. âœ… E4 simulation kernel covered (decay, TTL, fatigue, cooldowns)
5. âœ… E5 global systems covered (GCL, power, keeper lairs, nukers)
6. âœ… E8 core observability covered (telemetry emission)
7. âœ… Edge cases covered (overflow, TTL, conflicts)
8. âœ… E9 exclusion documented (AI logic not implemented, will be added when E9 complete)

### Phase 5-6 (Automation)
1. âœ… Parity tests run in CI/CD
2. âœ… Regression detection operational
3. âœ… Documentation complete (this file updated)
4. âœ… All tests passing (expected divergences documented)

---

## Verification

### Manual Testing

```bash
# 1. Clone official Screeps repositories
cd tools/parity-harness/scripts
./clone-repos.sh

# 2. Run Node.js fixture
cd ../test-runner
node run-fixture.js ../../../src/ScreepsDotNet.Engine.Tests/Parity/Fixtures/Harvest/basic.json --output basic.node.json

# 3. Run .NET parity test (from repo root)
cd ../../..
dotnet test --filter "FullyQualifiedName~HarvestParityTests.BasicHarvest"

# 4. Check for divergences (should be empty)
```

### CI Testing

Push to GitHub and verify workflow passes:
- Node.js harness builds
- All fixtures execute in both engines
- No divergences detected
- Test results published

---

## Risks & Mitigations

### Risk 1: Node.js Engine Requires Full Driver Infrastructure
**Impact:** HIGH - May block test harness development
**Mitigation:** Create lightweight mocks for bulk writers, stats, event log. Start with minimal mocks and expand as needed.

### Risk 2: Output Formats Don't Match Exactly
**Impact:** MEDIUM - Comparison engine may report false positives
**Mitigation:** Design fixture output format from scratch to work for both engines. Use JSON schema validation.

### Risk 3: Floating-Point Precision Differences
**Impact:** LOW - May cause false divergences in numeric fields
**Mitigation:** Implement tolerance-based comparison for numeric fields (e.g., Â±0.001).

### Risk 4: Divergences Found in Core Mechanics
**Impact:** EXPECTED - This is the purpose of E7
**Mitigation:** Document known divergences and fix systematically. Prioritize parity-critical mechanics.

---

## Open Questions

1. **Should parity tests run on every CI build or nightly?**
   - Recommendation: Run on every PR, but allow marking fixtures as "skip-ci" if they're slow.

2. **How to handle acceptable divergences (e.g., performance optimizations)?**
   - Recommendation: Document in this file and create "expected divergence" annotations in fixtures.

3. **Should we create parity tests for validation (E3) separately?**
   - Recommendation: Yes, Phase 4.3 covers this. Use separate fixture set for rejected intents.

4. **How many fixtures should we aim for?**
   - Recommendation: Start with 40-60 core fixtures (Phase 4.1-4.2), expand to 100+ over time.

---

## Implementation Status

### Phase 1: Node.js Test Harness
- [x] Step 1.1: Repository Setup
- [x] Step 1.2: Fixture Loader
- [x] Step 1.3: Processor Executor
- [x] Step 1.4: Output Serializer
- [x] Step 1.5: CLI Wrapper

### Phase 2: .NET Test Runner
- [ ] Step 2.1: Fixture Loader
- [ ] Step 2.2: Test Runner
- [ ] Step 2.3: Output Serializer
- [ ] Step 2.4: Parity Test Base Class

### Phase 3: Comparison Engine
- [ ] Step 3.1: Field-by-Field Diff
- [ ] Step 3.2: Divergence Reporter

### Phase 4: Parity Test Suite
- [ ] Step 4.1: Core Mechanics Fixtures (30-40)
- [ ] Step 4.2: Edge Cases (15-20)
- [ ] Step 4.3: Validation Parity (4-6)
- [ ] Step 4.4: Test Organization

### Phase 5: Automation & CI
- [ ] Step 5.1: Fixture Runner Script
- [ ] Step 5.2: GitHub Actions Workflow
- [ ] Step 5.3: Version Pinning Strategy

### Phase 6: Documentation
- [ ] Step 6.1: Update This Document
- [ ] Step 6.2: Update Roadmap
- [ ] Step 6.3: Add Operator Playbook Entry

---

## Cross-References

**Roadmap:** `docs/engine/roadmap.md` â†’ E7 milestone entry
**Features Tested:**
- **E1 Plan:** `docs/engine/e1.md` â†’ Basic intent processing
- **E2 Plan:** `docs/engine/e2.md` â†’ All 11 handler families (240 tests)
- **E3 Plan:** `docs/engine/e3.md` â†’ Intent validation rules
- **E4 Plan:** `docs/engine/e4.md` â†’ Simulation kernel (decay, TTL, fatigue, cooldowns)
- **E5 Plan:** `docs/engine/e5.md` â†’ Global systems (GCL, power, keeper lairs, nukers)
- **E6 Plan:** `docs/engine/e6.md` â†’ Engine orchestration
**Official Screeps Repos:**
- Engine: https://github.com/screeps/engine
- Driver: https://github.com/screeps/driver
- Common: https://github.com/screeps/common
**Test Infrastructure:** `src/ScreepsDotNet.Engine.Tests/Parity/`
**Parity Harness:** `tools/parity-harness/engine/` (Phase 1 complete âœ…)

---

**Last Updated:** 2026-01-22
**Status:** ðŸš§ In Progress (Phase 1 complete âœ…)
**Milestone Goal:** Build parity testing infrastructure
**Feature Coverage:** E1-E6, E8 complete (~95% of gameplay) | E9 not implemented (AI logic)
